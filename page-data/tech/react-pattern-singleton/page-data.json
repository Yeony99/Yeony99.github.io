{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/tech/react-pattern-singleton",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"category":"tech","slug":"/tech/react-pattern-singleton","tags":["Patterns"],"date":"2022-09-18","img":null,"title":"싱글톤 패턴"},"excerpt":"시리즈를 시작하며... patterns…","html":"<h2 id=\"시리즈를-시작하며\" style=\"position:relative;\">시리즈를 시작하며...<a href=\"#%EC%8B%9C%EB%A6%AC%EC%A6%88%EB%A5%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0\" aria-label=\"시리즈를 시작하며 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://www.patterns.dev/\">patterns</a>에 정리된 리액트 프로젝트 패턴을 공부하며 정리하는 글임을 알립니다.<br>\n시리즈 내 모든 글의 출처는 위 사이트를 기반으로 합니다.</p>\n<p>별도 참고 자료가 있을 시 해당 자료의 출처만 기재합니다.</p>\n<br/>\n<hr>\n<h2 id=\"디자인-패턴이란\" style=\"position:relative;\">디자인 패턴이란<a href=\"#%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\" aria-label=\"디자인 패턴이란 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>디자인 패턴은 소프트웨어 개발 과정에서 발생하는 문제에 해결책을 제시하는 개념입니다. 구현을 직접적으로 제공하지는 않지만, 문제 상황을 최적화된 방법으로 해결할 수 있도록 돕는 컨셉입니다.\n<br/></p>\n<hr>\n<h2 id=\"싱글톤-패턴-singleton-pattern\" style=\"position:relative;\">싱글톤 패턴 (Singleton Pattern)<a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-singleton-pattern\" aria-label=\"싱글톤 패턴 singleton pattern permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>싱글톤은 <strong>단 한 번만 인스턴스화 가능</strong>하며, <strong>전역(global)</strong> 에서 접근 가능한 클래스를 일컫습니다. <i>Singleton 인스턴스</i>는 앱 전역에서 공유되어, 앱 전역 상태관리에 적합합니다.\n<br/></p>\n<h3 id=\"단-한-번만-인스턴스화-가능\" style=\"position:relative;\">단 한 번만 인스턴스화 가능<a href=\"#%EB%8B%A8-%ED%95%9C-%EB%B2%88%EB%A7%8C-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94-%EA%B0%80%EB%8A%A5\" aria-label=\"단 한 번만 인스턴스화 가능 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 말의 의미는 <code class=\"language-text\">new</code> 키워드로 인스턴스 생성을 여러 번 하지 못한다는 의미입니다.</p>\n<p>일반적인 인스턴스 생성방법은 이렇습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let counter = 0\n\nclass Counter {\n  getInstance() {\n    return this\n  }\n\n  getCount() {\n    return counter\n  }\n\n  increment() {\n    return ++counter\n  }\n\n  decrement() {\n    return --counter\n  }\n}\n\nconst counter1 = new Counter()\nconst counter2 = new Counter()\n\nconsole.log(counter1.getInstance() === counter2.getInstance()) // false</code>\n        </deckgo-highlight-code>\n<p>이렇게 <code class=\"language-text\">new</code> 키워드로 생성한 인스턴스는 서로 같지 않음을 알 수 있습니다. 인스턴스가 다르다는 것은 같은 레퍼런스를 가지지 않는다는 의미입니다.</p>\n<p>그렇다면 동일한 레퍼런스를 가지게 하려면 어떻게 하면 될까요? 여러 방법이 있습니다.</p>\n<h4 id=\"instance-변수-만들기\" style=\"position:relative;\">instance 변수 만들기<a href=\"#instance-%EB%B3%80%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"instance 변수 만들기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let instance // instance 변수 선언\nlet counter = 0\n\nclass Counter {\n  constructor() {\n    if (instance) {\n      // instance가 존재하면 에러 발생시키기\n      throw new Error(&quot;인스턴스는 한 번만 만들 수 있습니다!&quot;)\n    }\n  }\n\n  getInstance() {\n    return this\n  }\n\n  getCount() {\n    return counter\n  }\n\n  increment() {\n    return ++counter\n  }\n\n  decrement() {\n    return --counter\n  }\n}\n\nconst singletonCounter = Object.freeze(new Counter())\n// const counter2 = new Counter() // 에러 발생</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">constructor</code> 생성자에 객체 초기화시 instance가 이미 있는지 여부를 확인합니다. 그리고 <code class=\"language-text\">Object.freeze</code>를 통해 객체를 수정할 수 없게 합니다.</p>\n<p>인스턴스를 하나만 만들게 강제하는 방식에는 장단점이 있습니다.</p>\n<ul>\n<li>장점\n<ul>\n<li>메모리 공간 절약</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li>자바스크립트 언어 자체의 한계점이 있다. 클래스 작성 없이도 객체를 만들 수 있기 때문에 일종의 오버 엔지니어링에 해당</li>\n<li>JS에서 싱글톤은 안티패턴으로 취급됨</li>\n</ul>\n</li>\n</ul>\n<p>위의 예제는 <code class=\"language-text\">class</code>로 객체를 생성해 컨트롤하였는데, 자바스크립트는 그냥 <code class=\"language-text\">const counter = {}</code> 라는 간단한 할당으로 객체 리터럴을 만들 수 있습니다. 따라서 위와 같은 패턴은 적합하지는 않습니다.</p>\n<h3 id=\"객체-리터럴-사용\" style=\"position:relative;\">객체 리터럴 사용<a href=\"#%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EC%82%AC%EC%9A%A9\" aria-label=\"객체 리터럴 사용 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let count = 0\n\nconst counter = {\n  increment() {\n    return ++count\n  },\n\n  decrement() {\n    return --count\n  },\n}\n\nObject.freeze(counter)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">class</code>로 인스턴스를 생성하는 것보다 훨씬 간편하다고 느껴집니다.</p>\n<h3 id=\"테스팅\" style=\"position:relative;\">테스팅<a href=\"#%ED%85%8C%EC%8A%A4%ED%8C%85\" aria-label=\"테스팅 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>싱글톤 패턴으로 구현된 코드를 테스트하는 것은 조금 까다롭다고 합니다. 인스턴스를 한 번만 생성할 수 있기 때문에, 이전에 생성된 전역 인스턴스를 수정하는 방향으로 테스트가 진행됩니다. 테스트 진행에 순서가 생기게 되면 이전 테스트에서 사용된 값이 남아있어 원활히 진행되지 못할 수 있습니다.</p>\n<p>따라서 하나의 테스트가 끝나면 인스턴스 변경사항들을 초기화한 후 다음 테스트를 진행합니다.</p>\n<p>patterns에서는 테스트 라이브러리 <strong>jest</strong> 를 사용한 예제를 제공하였습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 테스트를 진행할 인스턴스 불러오기\nimport Counter from &quot;../src/counterTest&quot;\n\ntest(&quot;incrementing 1 time should be 1&quot;, () =&gt; {\n  Counter.increment()\n  expect(Counter.getCount()).toBe(1)\n})\n\ntest(&quot;incrementing 3 extra times should be 4&quot;, () =&gt; {\n  Counter.increment()\n  Counter.increment()\n  Counter.increment()\n  expect(Counter.getCount()).toBe(4)\n})\n\ntest(&quot;decrementing 1  times should be 3&quot;, () =&gt; {\n  Counter.decrement()\n  expect(Counter.getCount()).toBe(3)\n})</code>\n        </deckgo-highlight-code>\n<!-- 추가) js test, test libraries -->\n<br/>\n<hr>\n<h2 id=\"리액트의-상태관리\" style=\"position:relative;\">리액트의 상태관리<a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC\" aria-label=\"리액트의 상태관리 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>React를 사용하며 전역 상태 관리가 필요할 때에는 싱글톤 객체를 만들기보다 <strong>Redux</strong>나 <strong>React Context</strong>를 사용합니다.</p>\n<p>싱글톤 객체가 인스턴스 값을 직접 수정할 수 있다면, 위 두 가지 도구는 <strong>read only</strong> 상태를 갖도록 합니다. 디스패처 => (액션) => 실행 => 순수함수 reducer => 상태 업데이트로 이뤄지는 과정은 개발자가 의도한대로만 전역 상태가 움직이도록 그 흐름과 제어를 명확히 한다는 장점이 있습니다.</p>\n<!-- ◾ [변수 명명 규칙](/tech/let-me-know-js-a-bit-js-variable-naming) 👈 이전 글 보기    -->","internal":{"content":"\n## 시리즈를 시작하며...\n\n[patterns](https://www.patterns.dev/)에 정리된 리액트 프로젝트 패턴을 공부하며 정리하는 글임을 알립니다.  \n시리즈 내 모든 글의 출처는 위 사이트를 기반으로 합니다.\n\n별도 참고 자료가 있을 시 해당 자료의 출처만 기재합니다.\n\n<br/>\n\n---\n\n## 디자인 패턴이란\n\n디자인 패턴은 소프트웨어 개발 과정에서 발생하는 문제에 해결책을 제시하는 개념입니다. 구현을 직접적으로 제공하지는 않지만, 문제 상황을 최적화된 방법으로 해결할 수 있도록 돕는 컨셉입니다.\n<br/>\n\n---\n## 싱글톤 패턴 (Singleton Pattern)\n\n싱글톤은 **단 한 번만 인스턴스화 가능**하며, **전역(global)** 에서 접근 가능한 클래스를 일컫습니다. <i>Singleton 인스턴스</i>는 앱 전역에서 공유되어, 앱 전역 상태관리에 적합합니다.\n<br/>\n\n### 단 한 번만 인스턴스화 가능\n\n이 말의 의미는 `new` 키워드로 인스턴스 생성을 여러 번 하지 못한다는 의미입니다.\n\n일반적인 인스턴스 생성방법은 이렇습니다.\n\n```javascript\nlet counter = 0\n\nclass Counter {\n  getInstance() {\n    return this\n  }\n\n  getCount() {\n    return counter\n  }\n\n  increment() {\n    return ++counter\n  }\n\n  decrement() {\n    return --counter\n  }\n}\n\nconst counter1 = new Counter()\nconst counter2 = new Counter()\n\nconsole.log(counter1.getInstance() === counter2.getInstance()) // false\n```\n\n이렇게 `new` 키워드로 생성한 인스턴스는 서로 같지 않음을 알 수 있습니다. 인스턴스가 다르다는 것은 같은 레퍼런스를 가지지 않는다는 의미입니다.\n\n그렇다면 동일한 레퍼런스를 가지게 하려면 어떻게 하면 될까요? 여러 방법이 있습니다.\n\n#### instance 변수 만들기\n\n```javascript\nlet instance // instance 변수 선언\nlet counter = 0\n\nclass Counter {\n  constructor() {\n    if (instance) {\n      // instance가 존재하면 에러 발생시키기\n      throw new Error(\"인스턴스는 한 번만 만들 수 있습니다!\")\n    }\n  }\n\n  getInstance() {\n    return this\n  }\n\n  getCount() {\n    return counter\n  }\n\n  increment() {\n    return ++counter\n  }\n\n  decrement() {\n    return --counter\n  }\n}\n\nconst singletonCounter = Object.freeze(new Counter())\n// const counter2 = new Counter() // 에러 발생\n```\n\n`constructor` 생성자에 객체 초기화시 instance가 이미 있는지 여부를 확인합니다. 그리고 `Object.freeze`를 통해 객체를 수정할 수 없게 합니다.\n\n인스턴스를 하나만 만들게 강제하는 방식에는 장단점이 있습니다.\n\n- 장점\n  - 메모리 공간 절약\n- 단점\n  - 자바스크립트 언어 자체의 한계점이 있다. 클래스 작성 없이도 객체를 만들 수 있기 때문에 일종의 오버 엔지니어링에 해당\n  - JS에서 싱글톤은 안티패턴으로 취급됨\n\n위의 예제는 `class`로 객체를 생성해 컨트롤하였는데, 자바스크립트는 그냥 `const counter = {}` 라는 간단한 할당으로 객체 리터럴을 만들 수 있습니다. 따라서 위와 같은 패턴은 적합하지는 않습니다.\n\n### 객체 리터럴 사용\n\n```javascript\nlet count = 0\n\nconst counter = {\n  increment() {\n    return ++count\n  },\n\n  decrement() {\n    return --count\n  },\n}\n\nObject.freeze(counter)\n```\n\n`class`로 인스턴스를 생성하는 것보다 훨씬 간편하다고 느껴집니다.\n\n### 테스팅\n\n싱글톤 패턴으로 구현된 코드를 테스트하는 것은 조금 까다롭다고 합니다. 인스턴스를 한 번만 생성할 수 있기 때문에, 이전에 생성된 전역 인스턴스를 수정하는 방향으로 테스트가 진행됩니다. 테스트 진행에 순서가 생기게 되면 이전 테스트에서 사용된 값이 남아있어 원활히 진행되지 못할 수 있습니다.\n\n따라서 하나의 테스트가 끝나면 인스턴스 변경사항들을 초기화한 후 다음 테스트를 진행합니다.\n\npatterns에서는 테스트 라이브러리 **jest** 를 사용한 예제를 제공하였습니다.\n\n```javascript\n// 테스트를 진행할 인스턴스 불러오기\nimport Counter from \"../src/counterTest\"\n\ntest(\"incrementing 1 time should be 1\", () => {\n  Counter.increment()\n  expect(Counter.getCount()).toBe(1)\n})\n\ntest(\"incrementing 3 extra times should be 4\", () => {\n  Counter.increment()\n  Counter.increment()\n  Counter.increment()\n  expect(Counter.getCount()).toBe(4)\n})\n\ntest(\"decrementing 1  times should be 3\", () => {\n  Counter.decrement()\n  expect(Counter.getCount()).toBe(3)\n})\n```\n\n<!-- 추가) js test, test libraries -->\n\n<br/>\n\n---\n\n## 리액트의 상태관리\n\nReact를 사용하며 전역 상태 관리가 필요할 때에는 싱글톤 객체를 만들기보다 **Redux**나 **React Context**를 사용합니다.\n\n싱글톤 객체가 인스턴스 값을 직접 수정할 수 있다면, 위 두 가지 도구는 **read only** 상태를 갖도록 합니다. 디스패처 => (액션) => 실행 => 순수함수 reducer => 상태 업데이트로 이뤄지는 과정은 개발자가 의도한대로만 전역 상태가 움직이도록 그 흐름과 제어를 명확히 한다는 장점이 있습니다.\n\n<!-- ◾ [변수 명명 규칙](/tech/let-me-know-js-a-bit-js-variable-naming) 👈 이전 글 보기    -->\n"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%8B%9C%EB%A6%AC%EC%A6%88%EB%A5%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0\">시리즈를 시작하며...</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\">디자인 패턴이란</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-singleton-pattern\">싱글톤 패턴 (Singleton Pattern)</a></p>\n<ul>\n<li>\n<p><a href=\"#%EB%8B%A8-%ED%95%9C-%EB%B2%88%EB%A7%8C-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94-%EA%B0%80%EB%8A%A5\">단 한 번만 인스턴스화 가능</a></p>\n<ul>\n<li><a href=\"#instance-%EB%B3%80%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0\">instance 변수 만들기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EC%82%AC%EC%9A%A9\">객체 리터럴 사용</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%85%8C%EC%8A%A4%ED%8C%85\">테스팅</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC\">리액트의 상태관리</a></p>\n</li>\n</ul>"}}]}},"pageContext":{"slug":"/tech/react-pattern-singleton"}},
    "staticQueryHashes": ["2665612806"]}