{"componentChunkName":"component---src-templates-blog-post-js","path":"/tech/let-me-know-js-a-bit-shallow-copy-deep-copy","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"category":"tech","slug":"/tech/let-me-know-js-a-bit-shallow-copy-deep-copy","tags":["쫌만알자"],"date":"2022-11-09","img":"https://user-images.githubusercontent.com/76241233/177932893-5a504b26-12e4-4ade-b1ce-1951d072ba82.jpg","title":"쫌만알자! (16) - 얕은 복사와 깊은 복사"},"excerpt":"우리는 자바스크립트에서 값을 할당할 수 있다는 것을 압니다. 이미 할당된 변수에 다른 변수의 값을 재할당할 수 있다는 것도 알죠. 하지만 객체의 경우 메모리 상에서 참조(Reference…","html":"<p>우리는 자바스크립트에서 값을 할당할 수 있다는 것을 압니다. 이미 할당된 변수에 다른 변수의 값을 재할당할 수 있다는 것도 알죠.</p>\n<p>하지만 객체의 경우 메모리 상에서 <strong>참조(Reference)</strong> 된다는 것도 알았습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let o1 = {\r\n  name: &#39;yeony&#39;\r\n}\r\n\r\nlet o2 = o1\r\n\r\nconsole.log(o1 === o2) // true</code>\n        </deckgo-highlight-code>\n<p>언뜻 보면 객체를 복사한 것처럼 보이지만 둘은 서로 같은 객체죠. 바로 <strong>같은 메모리 주소를 참조</strong>하고 있기 때문입니다.</p>\n<p>이번 글에서는 참조되지 않는 복사를 한 번 알아봅시다.</p>\n<hr>\n<h2 id=\"얕은-복사-vs-깊은-복사-shallow-copy-vs-deep-copy\" style=\"position:relative;\">얕은 복사 vs 깊은 복사 (Shallow Copy vs Deep Copy)<a href=\"#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-vs-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC-shallow-copy-vs-deep-copy\" aria-label=\"얕은 복사 vs 깊은 복사 shallow copy vs deep copy permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자바스크립트에서 할 수 있는 복사는 크게 두 종류로 나뉩니다. <strong>얕은 복사</strong>와 <strong>깊은 복사</strong>입니다.</p>\n<p>얕은 복사는 중접된 객체의 한 단계까지 복사하고, 깊은 복사는 중접된 객체까지 모두 복사합니다.</p>\n<h3 id=\"얕은-복사\" style=\"position:relative;\">얕은 복사<a href=\"#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"얕은 복사 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>얕은 복사는 참조된 값(객체의 메모리 주소)를 복사해 같은 객체를 참조하게 됩니다.</p>\n<p>얕은 복사는 3가지 방법이 있습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const obj = {\r\n  objValue: &#39;objValue&#39;,\r\n  nested: {\r\n    key: &#39;value&#39;\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<p>위 객체를 기준으로 살펴봅시다.</p>\n<h4 id=\"스프레드spread-연산자\" style=\"position:relative;\">스프레드(Spread) 연산자<a href=\"#%EC%8A%A4%ED%94%84%EB%A0%88%EB%93%9Cspread-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"스프레드spread 연산자 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>spread라는 단어의 의미는 펼치다, 퍼트리다입니다. 즉 <strong>전개</strong>하는 연산자입니다.</p>\n<p><code class=\"language-text\">...</code> 이렇게 점 3개를 연달아 작성하는 연산자인데요. ES6에 도입된 문법입니다. 이 연산자를 사용하면 객체의 프로퍼티를 펼쳐서 복사하는 것입니다. 객체와 배열에서 사용할 수 있습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const obj = {\r\n  objValue: &#39;objValue&#39;,\r\n  nested: {\r\n    key: &#39;value&#39;\r\n  }\r\n}\r\n\r\nconst spread = {\r\n  ...obj\r\n}\r\n\r\n// 서로 다른 객체\r\nconsole.log(obj === spread) // false\r\n\r\n// obj의 중접 객체의 프로퍼티 값 변경\r\nobj.nested.key = &#39;valueChanged&#39;\r\n\r\n// spread의 중첩 객체 프로퍼티 값이 같이 변함\r\nconsole.log(obj.nested.key === spread.nested.key) // true</code>\n        </deckgo-highlight-code>\n<p>복사된 객체와 원본 객체는 <strong>서로 다른 객체</strong>입니다. <code class=\"language-text\">=</code> 연산자로 할당했을 때 객체가 서로 같았던 것과는 확실히 다릅니다.</p>\n<p>그럼에도 중첩된 객체의 값은 여전히 서로 참조되어 같이 움직입니다.</p>\n<p>그렇다면 spread 객체에 새로운 프로퍼티를 추가해보면 어떻게 동작할까요?</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">spread.spreadOnly = &#39;onlySpreadValue&#39;\r\n\r\nconsole.log(spread) // objValue: &#39;objValue&#39;, nested: {key: &#39;valueChanged&#39;, key2: &#39;value2&#39;}, spreadOnly: &#39;onlySpreadValue!&#39;\r\nconsole.log(obj)    // objValue: &#39;objValue&#39;, nested: {key: &#39;valueChanged&#39;, key2: &#39;value2&#39;}</code>\n        </deckgo-highlight-code>\n<p>spread 객체에만 값이 들어갔습니다! 앞서 말했듯 두 객체는 <strong>서로 다른 객체</strong>이지만, <strong>중첩된 객체에 같은 참조를 가지고</strong> 있기 때문에 이러한 결과가 나온 것입니다.</p>\n<h4 id=\"레스트rest\" style=\"position:relative;\">레스트(rest)<a href=\"#%EB%A0%88%EC%8A%A4%ED%8A%B8rest\" aria-label=\"레스트rest permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><strong>나머지</strong>를 가져오는 방식입니다. 스프레드 연산자와 유사하게 생겼지만 엄연히 다릅니다.</p>\n<p>rest는 객체, 배열, 함수의 파라미터에서 사용할 수 있습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const obj = {\r\n  objValue: &#39;objValue&#39;,\r\n  nested: {\r\n    key: &#39;value&#39;\r\n  }\r\n}\r\n\r\nconst { objValue, ...rest } = obj\r\n\r\nconsole.log(rest) // nested: {key: &#39;value&#39;}\r\n\r\n// obj의 중접 객체의 프로퍼티 값 변경\r\nobj.nested.key = &#39;valueChanged&#39;\r\nconsole.log(rest.nested.value) // &#39;valueChanged&#39;</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">objValue</code>를 제외한 <strong>나머지</strong> 프로퍼티들이 복사되었고, 중첩된 객체의 값은 여전히 참조되어 있는 것을 확인할 수 있습니다.</p>\n<h4 id=\"objectassign\" style=\"position:relative;\">Object.assign()<a href=\"#objectassign\" aria-label=\"objectassign permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">Object.assign</code> 은 자바스크립트의 내장 메소드입니다.</p>\n<p><code class=\"language-text\">Object.assign(타깃, 원본 객체)</code>로 작성하면 얕은 복사된 객체를 돌려줍니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const obj = {\r\n  objValue: &#39;objValue&#39;,\r\n  nested: {\r\n    key: &#39;value&#39;\r\n  }\r\n}\r\n\r\nconst assigned = Object.assign({}, obj)\r\n\r\nconsole.log(obj === assigned) // false\r\n\r\n// obj의 중접 객체의 프로퍼티 값 변경\r\nobj.nested.key = &#39;valueChanged&#39;\r\nconsole.log(assigned.nested.value) // &#39;valueChanged&#39;</code>\n        </deckgo-highlight-code>\n<p>역시나 중첩된 객체 값은 참조되어 있습니다.</p>\n<h3 id=\"깊은-복사\" style=\"position:relative;\">깊은 복사<a href=\"#%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"깊은 복사 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>얕은 복사는 중첩된 객체의 경우 계속 참조되는 것을 보았습니다.</p>\n<p>반면 깊은 복사는 얕은 복사와는 달리, 원본과 복사본 중 어떤 값을 바꾸어도 <strong>서로에 영향이 없다</strong>는 것을 보증합니다.</p>\n<p>자바스크립트에서 깊은 복사를 생성하는 방법은 한 가지입니다.</p>\n<p>아직은 낯선 개념이겠지만 언급하고 넘어갑니다.</p>\n<h4 id=\"jsonstringify와-jsonparse-사용\" style=\"position:relative;\">JSON.stringify()와 JSON.parse() 사용<a href=\"#jsonstringify%EC%99%80-jsonparse-%EC%82%AC%EC%9A%A9\" aria-label=\"jsonstringify와 jsonparse 사용 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>JSON은 JavaScript Object Notation인데, 이후에 자세히 알아보도록 하겠습니다.</p>\n<p><code class=\"language-text\">JSON.stringify()</code>는 이름에서 유추할 수 있듯이 자바스크립트 값 혹은 객체를 JSON <strong>문자열</strong>로 변환합니다.</p>\n<p><code class=\"language-text\">JSON.parse()</code>는 JSON 문자열의 구문을 **분석(parse)**하고 그 결과를 바탕으로 자바스크립트 값이나 객체를 생성합니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const obj = {\r\n  objValue: &#39;objValue&#39;,\r\n  nested: {\r\n    key: &#39;value&#39;\r\n  }\r\n}\r\n\r\nJSON.stringify(obj) // &#39;{&quot;objValue&quot;:&quot;objValue&quot;,&quot;nested&quot;:{&quot;key&quot;:&quot;value&quot;}}&#39;\r\n\r\nconst deepCopy = JSON.parse(JSON.stringify(obj))\r\n\r\n// obj의 중접 객체의 프로퍼티 값 변경\r\nobj.nested.key = &#39;valueChanged&#39;\r\n\r\n// 변하지 않은 deepCopy의 중첩 객체 값\r\nconsole.log(deepCopy.nested.value) // &#39;value&#39;</code>\n        </deckgo-highlight-code>\n<p>원본 객체를 수정하였지만 deepCopy 객체의 값은 아무것도 달라지지 않았습니다.</p>\n<p>다음 글에서는 함수를 알아보겠습니다.</p>\n<h2 id=\"reference\" style=\"position:relative;\">Reference<a href=\"#reference\" aria-label=\"reference permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://dmitripavlutin.com/javascript-shallow-clone-objects/\">3 Ways to Shallow Clone Objects in JavaScript</a><br>\n<a href=\"https://blog.bitsrc.io/shallow-copy-and-deep-copy-in-javascript-d0ca570cd4cf\">Shallow Copy vs Deep Copy in JavaScript</a></p>\n<p>◾ <a href=\"/tech/let-me-know-js-a-bit-js-memory\">자바스크립트의 메모리</a> 👈 이전 글 보기</p>","internal":{"content":"\r\n우리는 자바스크립트에서 값을 할당할 수 있다는 것을 압니다. 이미 할당된 변수에 다른 변수의 값을 재할당할 수 있다는 것도 알죠.\r\n\r\n하지만 객체의 경우 메모리 상에서 **참조(Reference)** 된다는 것도 알았습니다.\r\n\r\n```javascript\r\nlet o1 = {\r\n  name: 'yeony'\r\n}\r\n\r\nlet o2 = o1\r\n\r\nconsole.log(o1 === o2) // true\r\n```\r\n\r\n언뜻 보면 객체를 복사한 것처럼 보이지만 둘은 서로 같은 객체죠. 바로 **같은 메모리 주소를 참조**하고 있기 때문입니다.\r\n\r\n이번 글에서는 참조되지 않는 복사를 한 번 알아봅시다.\r\n\r\n---\r\n\r\n## 얕은 복사 vs 깊은 복사 (Shallow Copy vs Deep Copy)\r\n\r\n자바스크립트에서 할 수 있는 복사는 크게 두 종류로 나뉩니다. **얕은 복사**와 **깊은 복사**입니다.\r\n\r\n얕은 복사는 중접된 객체의 한 단계까지 복사하고, 깊은 복사는 중접된 객체까지 모두 복사합니다. \r\n\r\n### 얕은 복사\r\n\r\n얕은 복사는 참조된 값(객체의 메모리 주소)를 복사해 같은 객체를 참조하게 됩니다. \r\n\r\n얕은 복사는 3가지 방법이 있습니다.\r\n\r\n```javascript\r\nconst obj = {\r\n  objValue: 'objValue',\r\n  nested: {\r\n    key: 'value'\r\n  }\r\n}\r\n```\r\n\r\n위 객체를 기준으로 살펴봅시다.\r\n\r\n#### 스프레드(Spread) 연산자\r\n\r\nspread라는 단어의 의미는 펼치다, 퍼트리다입니다. 즉 **전개**하는 연산자입니다. \r\n\r\n`...` 이렇게 점 3개를 연달아 작성하는 연산자인데요. ES6에 도입된 문법입니다. 이 연산자를 사용하면 객체의 프로퍼티를 펼쳐서 복사하는 것입니다. 객체와 배열에서 사용할 수 있습니다.\r\n\r\n```javascript\r\nconst obj = {\r\n  objValue: 'objValue',\r\n  nested: {\r\n    key: 'value'\r\n  }\r\n}\r\n\r\nconst spread = {\r\n  ...obj\r\n}\r\n\r\n// 서로 다른 객체\r\nconsole.log(obj === spread) // false\r\n\r\n// obj의 중접 객체의 프로퍼티 값 변경\r\nobj.nested.key = 'valueChanged'\r\n\r\n// spread의 중첩 객체 프로퍼티 값이 같이 변함\r\nconsole.log(obj.nested.key === spread.nested.key) // true\r\n```\r\n\r\n복사된 객체와 원본 객체는 **서로 다른 객체**입니다. `=` 연산자로 할당했을 때 객체가 서로 같았던 것과는 확실히 다릅니다.\r\n\r\n그럼에도 중첩된 객체의 값은 여전히 서로 참조되어 같이 움직입니다. \r\n\r\n그렇다면 spread 객체에 새로운 프로퍼티를 추가해보면 어떻게 동작할까요?\r\n\r\n```javascript\r\nspread.spreadOnly = 'onlySpreadValue'\r\n\r\nconsole.log(spread) // objValue: 'objValue', nested: {key: 'valueChanged', key2: 'value2'}, spreadOnly: 'onlySpreadValue!'\r\nconsole.log(obj)    // objValue: 'objValue', nested: {key: 'valueChanged', key2: 'value2'}\r\n```\r\n\r\nspread 객체에만 값이 들어갔습니다! 앞서 말했듯 두 객체는 **서로 다른 객체**이지만, **중첩된 객체에 같은 참조를 가지고** 있기 때문에 이러한 결과가 나온 것입니다.\r\n\r\n\r\n#### 레스트(rest) \r\n\r\n**나머지**를 가져오는 방식입니다. 스프레드 연산자와 유사하게 생겼지만 엄연히 다릅니다. \r\n\r\nrest는 객체, 배열, 함수의 파라미터에서 사용할 수 있습니다.\r\n\r\n```javascript\r\nconst obj = {\r\n  objValue: 'objValue',\r\n  nested: {\r\n    key: 'value'\r\n  }\r\n}\r\n\r\nconst { objValue, ...rest } = obj\r\n\r\nconsole.log(rest) // nested: {key: 'value'}\r\n\r\n// obj의 중접 객체의 프로퍼티 값 변경\r\nobj.nested.key = 'valueChanged'\r\nconsole.log(rest.nested.value) // 'valueChanged'\r\n```\r\n\r\n`objValue`를 제외한 **나머지** 프로퍼티들이 복사되었고, 중첩된 객체의 값은 여전히 참조되어 있는 것을 확인할 수 있습니다.\r\n\r\n\r\n#### Object.assign() \r\n\r\n`Object.assign` 은 자바스크립트의 내장 메소드입니다.\r\n\r\n`Object.assign(타깃, 원본 객체)`로 작성하면 얕은 복사된 객체를 돌려줍니다.\r\n\r\n```javascript\r\nconst obj = {\r\n  objValue: 'objValue',\r\n  nested: {\r\n    key: 'value'\r\n  }\r\n}\r\n\r\nconst assigned = Object.assign({}, obj)\r\n\r\nconsole.log(obj === assigned) // false\r\n\r\n// obj의 중접 객체의 프로퍼티 값 변경\r\nobj.nested.key = 'valueChanged'\r\nconsole.log(assigned.nested.value) // 'valueChanged'\r\n```\r\n\r\n역시나 중첩된 객체 값은 참조되어 있습니다.\r\n\r\n\r\n### 깊은 복사\r\n\r\n얕은 복사는 중첩된 객체의 경우 계속 참조되는 것을 보았습니다. \r\n\r\n반면 깊은 복사는 얕은 복사와는 달리, 원본과 복사본 중 어떤 값을 바꾸어도 **서로에 영향이 없다**는 것을 보증합니다.\r\n\r\n자바스크립트에서 깊은 복사를 생성하는 방법은 한 가지입니다.\r\n\r\n아직은 낯선 개념이겠지만 언급하고 넘어갑니다.\r\n\r\n#### JSON.stringify()와 JSON.parse() 사용\r\n\r\nJSON은 JavaScript Object Notation인데, 이후에 자세히 알아보도록 하겠습니다.\r\n\r\n`JSON.stringify()`는 이름에서 유추할 수 있듯이 자바스크립트 값 혹은 객체를 JSON **문자열**로 변환합니다. \r\n\r\n`JSON.parse()`는 JSON 문자열의 구문을 **분석(parse)**하고 그 결과를 바탕으로 자바스크립트 값이나 객체를 생성합니다.\r\n\r\n```javascript\r\nconst obj = {\r\n  objValue: 'objValue',\r\n  nested: {\r\n    key: 'value'\r\n  }\r\n}\r\n\r\nJSON.stringify(obj) // '{\"objValue\":\"objValue\",\"nested\":{\"key\":\"value\"}}'\r\n\r\nconst deepCopy = JSON.parse(JSON.stringify(obj))\r\n\r\n// obj의 중접 객체의 프로퍼티 값 변경\r\nobj.nested.key = 'valueChanged'\r\n\r\n// 변하지 않은 deepCopy의 중첩 객체 값\r\nconsole.log(deepCopy.nested.value) // 'value'\r\n```\r\n\r\n원본 객체를 수정하였지만 deepCopy 객체의 값은 아무것도 달라지지 않았습니다. \r\n\r\n다음 글에서는 함수를 알아보겠습니다.\r\n\r\n\r\n## Reference\r\n\r\n[3 Ways to Shallow Clone Objects in JavaScript](https://dmitripavlutin.com/javascript-shallow-clone-objects/)    \r\n[Shallow Copy vs Deep Copy in JavaScript](https://blog.bitsrc.io/shallow-copy-and-deep-copy-in-javascript-d0ca570cd4cf)\r\n\r\n\r\n◾ [자바스크립트의 메모리](/tech/let-me-know-js-a-bit-js-memory) 👈 이전 글 보기\r\n"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC-vs-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC-shallow-copy-vs-deep-copy\">얕은 복사 vs 깊은 복사 (Shallow Copy vs Deep Copy)</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC\">얕은 복사</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A0%88%EB%93%9Cspread-%EC%97%B0%EC%82%B0%EC%9E%90\">스프레드(Spread) 연산자</a></li>\n<li><a href=\"#%EB%A0%88%EC%8A%A4%ED%8A%B8rest\">레스트(rest)</a></li>\n<li><a href=\"#objectassign\">Object.assign()</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\">깊은 복사</a></p>\n<ul>\n<li><a href=\"#jsonstringify%EC%99%80-jsonparse-%EC%82%AC%EC%9A%A9\">JSON.stringify()와 JSON.parse() 사용</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>"}}]}},"pageContext":{"slug":"/tech/let-me-know-js-a-bit-shallow-copy-deep-copy"}},"staticQueryHashes":["2665612806"]}