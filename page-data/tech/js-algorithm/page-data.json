{"componentChunkName":"component---src-templates-blog-post-js","path":"/tech/js-algorithm","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"category":"tech","slug":"/tech/js-algorithm","tags":["Book"],"date":"2023-10-24","img":null,"title":"[JS 자료구조 & 알고리즘 (1)] 빅오 표기법"},"excerpt":"도서 자바스크립트로 하는 자료 구조와 알고리즘을 읽으며 정리하는 글 시리즈. 빅오 표기법 빅오 표기법은 알고리즘 실행에 있어 가장 최악의 경우인 복잡도를 측정한다.  에서 \"n\"은 입력의 개수를 나타낸다. Big O Complexity Chart…","html":"<p>도서 <strong>자바스크립트로 하는 자료 구조와 알고리즘</strong>을 읽으며 정리하는 글 시리즈.</p>\n<h2 id=\"빅오-표기법\" style=\"position:relative;\">빅오 표기법<a href=\"#%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95\" aria-label=\"빅오 표기법 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>빅오 표기법은 알고리즘 실행에 있어 가장 <strong>최악의 경우</strong>인 복잡도를 측정한다.</p>\n<p><code class=\"language-text\">O(n)</code> 에서 \"n\"은 입력의 개수를 나타낸다.</p>\n<p><img src=\"https://github.com/Yeony99/Yeony99/assets/76241233/095b8af4-9e6d-46f6-bf66-cffe375f9087\" alt=\"Big O Complexity Chart\">\r\n<span style=\"font-size: 13px\">이미지 출처: <a href=\"https://www.freecodecamp.org/news/all-you-need-to-know-about-big-o-notation-to-crack-your-next-coding-interview-9d575e7eec4/\">https://www.freecodecamp.org/news/all-you-need-to-know-about-big-o-notation-to-crack-your-next-coding-interview-9d575e7eec4/</a> <span></p>\n<h3 id=\"o1\" style=\"position:relative;\">O(1)<a href=\"#o1\" aria-label=\"o1 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>O(1)은 입력의 개수와 무관하다. 따라서 <strong>상수 시간</strong>이라고 부른다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const arr = [&#39;apple&#39;, &#39;banana&#39;];\r\n\r\nconsole.log(arr[0]); </code>\n        </deckgo-highlight-code>\n<p>배열의 인덱스, 객체의 key 등으로 접근하는 경우가 O(1) 알고리즘의 예시가 될 수 있다.</p>\n<h3 id=\"on-on-on\" style=\"position:relative;\">O(n), O(n²), O(n³)<a href=\"#on-on-on\" aria-label=\"on on on permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>O(n)은 일차시간이다. 입력 개수와 동일하게 실행된다.</p>\n<p>O(n²)은 이차시간이다. 입력의 개수의 제곱으로 실행된다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function foo(n) {\r\n    for(let i = 0; i &lt; n; i++) {\r\n        for(let j = 0; j &lt; n; j++) {\r\n            console.log(i, j);\r\n        }\r\n    }\r\n}\r\n\r\n// n이 3일 때, n의 제곱만큼 반복. (3 * 3)\r\n// 0 0\r\n// 0 1\r\n// 0 2\r\n// 1 0\r\n// 1 1\r\n// 1 2\r\n// 2 0\r\n// 2 1\r\n// 2 2</code>\n        </deckgo-highlight-code>\n<p>마찬가지로 O(n³)은 삼차시간이다. 입력 개수의 세제곱으로 실행된다.</p>\n<h3 id=\"ologn\" style=\"position:relative;\">O(log₂n)<a href=\"#ologn\" aria-label=\"ologn permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>로그 시간 복잡도를 나타낸다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function foo(n) {\r\n    for(let i = 1; i &lt; n; i = i*2) {\r\n        console.log(i)\r\n    }\r\n}\r\n</code>\n        </deckgo-highlight-code>\n<p>예시는 2의 제곱부터 n제곱 까지의 항목을 출력한다.</p>\n<p>위 경우에는 2의 제곱 값들을 입력하면 2의 n제곱 만큼 출력된다. (2의 제곱 사이에 있는 값을 입력하면 당연하게도 float 값 결과가 나온다.)</p>\n<p>로그 시간 복잡도는 입력 값이 커질 수록 효율이 증가한다.\r\n<br /></p>\n<h2 id=\"빅오-표기법-규칙\" style=\"position:relative;\">빅오 표기법 규칙<a href=\"#%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95-%EA%B7%9C%EC%B9%99\" aria-label=\"빅오 표기법 규칙 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>알고리즘 분석의 목표는 복잡도를 계산해 효율성을 이해하는 것이다. 이를 계산할 때의 유용한 규칙이 있다.</p>\n<h3 id=\"계수-법칙\" style=\"position:relative;\">계수 법칙<a href=\"#%EA%B3%84%EC%88%98-%EB%B2%95%EC%B9%99\" aria-label=\"계수 법칙 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>상수를 제거한다. 입력 크기와 연관되지 않는 상수를 무시한다.</p>\n<p>O(n)과 O(2n)은 n이 무한대로 향해 갈수록 별 차이가 없다. 임의의 상수 k가 붙는 경우도 마찬가지다. O(n)과 O(n + k)는 차이가 없는 것으로 본다.</p>\n<p>따라서 모두 O(n)으로 표기할 수 있다.</p>\n<h3 id=\"합의-법칙\" style=\"position:relative;\">합의 법칙<a href=\"#%ED%95%A9%EC%9D%98-%EB%B2%95%EC%B9%99\" aria-label=\"합의 법칙 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>O(n)과 O(n)을 더하면 O(2n)이 된다. 하지만 이는 계수법칙에 의해 O(n)으로 귀결된다.</p>\n<h3 id=\"곱의-법칙\" style=\"position:relative;\">곱의 법칙<a href=\"#%EA%B3%B1%EC%9D%98-%EB%B2%95%EC%B9%99\" aria-label=\"곱의 법칙 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>O(n)과 O(n)을 곱해보자. <code class=\"language-text\">n * n</code>은 n의 제곱이 된다. 따라서 O(n²)이다.<br>\nO(2n)과 O(n)인 경우도, O(2n²)이지만 계수법칙에 의해 O(n²)으로 나타낸다.</p>\n<h3 id=\"다항-법칙-빅오의-k제곱\" style=\"position:relative;\">다항 법칙 (빅오의 k제곱)<a href=\"#%EB%8B%A4%ED%95%AD-%EB%B2%95%EC%B9%99-%EB%B9%85%EC%98%A4%EC%9D%98-k%EC%A0%9C%EA%B3%B1\" aria-label=\"다항 법칙 빅오의 k제곱 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>다항 법칙은 다항 시간 복잡도가 동일한 다항 차수를 지닌 빅오 표기법을 지님을 나타낸다.<br>\n이게 무슨 의미냐면, k차 반복되면 O(n^k) 가 된다는 것이다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function foo(k) {\r\n    let count = 0;\r\n    for(let i = 0; i &lt; k * k; i++) {\r\n        count += 1;\r\n    }\r\n    return count;\r\n}</code>\n        </deckgo-highlight-code>\n<p>위의 예는 k차번 반복된다. k * k 이기 때문에 입력 값의 제곱수를 반환한다. 따라서 O(n²)이다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function foo(k) {\r\n    let count = 0;\r\n    for(let i = 0; i &lt; k * k * k; i++) {\r\n        count += 1;\r\n    }\r\n    return count;\r\n}</code>\n        </deckgo-highlight-code>\n<p>위의 예는 k * k * k 로 세제곱이다. O(n³)으로 나타낸다.</p>","internal":{"content":"\r\n도서 **자바스크립트로 하는 자료 구조와 알고리즘**을 읽으며 정리하는 글 시리즈.\r\n\r\n## 빅오 표기법\r\n\r\n빅오 표기법은 알고리즘 실행에 있어 가장 **최악의 경우**인 복잡도를 측정한다.\r\n\r\n`O(n)` 에서 \"n\"은 입력의 개수를 나타낸다.\r\n\r\n![Big O Complexity Chart](https://github.com/Yeony99/Yeony99/assets/76241233/095b8af4-9e6d-46f6-bf66-cffe375f9087)\r\n<span style=\"font-size: 13px\">이미지 출처: https://www.freecodecamp.org/news/all-you-need-to-know-about-big-o-notation-to-crack-your-next-coding-interview-9d575e7eec4/ <span>\r\n\r\n### O(1)\r\n\r\nO(1)은 입력의 개수와 무관하다. 따라서 **상수 시간**이라고 부른다.\r\n\r\n```javascript\r\nconst arr = ['apple', 'banana'];\r\n\r\nconsole.log(arr[0]); \r\n```\r\n\r\n배열의 인덱스, 객체의 key 등으로 접근하는 경우가 O(1) 알고리즘의 예시가 될 수 있다.\r\n\r\n\r\n### O(n), O(n²), O(n³)\r\n\r\nO(n)은 일차시간이다. 입력 개수와 동일하게 실행된다.   \r\n\r\n\r\nO(n²)은 이차시간이다. 입력의 개수의 제곱으로 실행된다.\r\n\r\n```javascript\r\nfunction foo(n) {\r\n    for(let i = 0; i < n; i++) {\r\n        for(let j = 0; j < n; j++) {\r\n            console.log(i, j);\r\n        }\r\n    }\r\n}\r\n\r\n// n이 3일 때, n의 제곱만큼 반복. (3 * 3)\r\n// 0 0\r\n// 0 1\r\n// 0 2\r\n// 1 0\r\n// 1 1\r\n// 1 2\r\n// 2 0\r\n// 2 1\r\n// 2 2\r\n```\r\n\r\n마찬가지로 O(n³)은 삼차시간이다. 입력 개수의 세제곱으로 실행된다.\r\n\r\n\r\n### O(log₂n)\r\n\r\n로그 시간 복잡도를 나타낸다.\r\n\r\n```javascript\r\nfunction foo(n) {\r\n    for(let i = 1; i < n; i = i*2) {\r\n        console.log(i)\r\n    }\r\n}\r\n\r\n```\r\n\r\n예시는 2의 제곱부터 n제곱 까지의 항목을 출력한다.\r\n\r\n위 경우에는 2의 제곱 값들을 입력하면 2의 n제곱 만큼 출력된다. (2의 제곱 사이에 있는 값을 입력하면 당연하게도 float 값 결과가 나온다.)\r\n\r\n로그 시간 복잡도는 입력 값이 커질 수록 효율이 증가한다.\r\n<br />\r\n\r\n## 빅오 표기법 규칙\r\n\r\n알고리즘 분석의 목표는 복잡도를 계산해 효율성을 이해하는 것이다. 이를 계산할 때의 유용한 규칙이 있다.\r\n\r\n### 계수 법칙\r\n\r\n상수를 제거한다. 입력 크기와 연관되지 않는 상수를 무시한다.\r\n\r\nO(n)과 O(2n)은 n이 무한대로 향해 갈수록 별 차이가 없다. 임의의 상수 k가 붙는 경우도 마찬가지다. O(n)과 O(n + k)는 차이가 없는 것으로 본다.\r\n\r\n따라서 모두 O(n)으로 표기할 수 있다.\r\n\r\n\r\n### 합의 법칙\r\n\r\nO(n)과 O(n)을 더하면 O(2n)이 된다. 하지만 이는 계수법칙에 의해 O(n)으로 귀결된다.\r\n\r\n\r\n### 곱의 법칙\r\n\r\nO(n)과 O(n)을 곱해보자. `n * n`은 n의 제곱이 된다. 따라서 O(n²)이다.    \r\nO(2n)과 O(n)인 경우도, O(2n²)이지만 계수법칙에 의해 O(n²)으로 나타낸다.\r\n\r\n\r\n### 다항 법칙 (빅오의 k제곱)\r\n\r\n다항 법칙은 다항 시간 복잡도가 동일한 다항 차수를 지닌 빅오 표기법을 지님을 나타낸다.    \r\n이게 무슨 의미냐면, k차 반복되면 O(n^k) 가 된다는 것이다.\r\n\r\n```javascript\r\nfunction foo(k) {\r\n    let count = 0;\r\n    for(let i = 0; i < k * k; i++) {\r\n        count += 1;\r\n    }\r\n    return count;\r\n}\r\n```\r\n\r\n위의 예는 k차번 반복된다. k * k 이기 때문에 입력 값의 제곱수를 반환한다. 따라서 O(n²)이다.\r\n\r\n```javascript\r\nfunction foo(k) {\r\n    let count = 0;\r\n    for(let i = 0; i < k * k * k; i++) {\r\n        count += 1;\r\n    }\r\n    return count;\r\n}\r\n```\r\n\r\n위의 예는 k * k * k 로 세제곱이다. O(n³)으로 나타낸다.\r\n\r\n"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95\">빅오 표기법</a></p>\n<ul>\n<li><a href=\"#o1\">O(1)</a></li>\n<li><a href=\"#on-on-on\">O(n), O(n²), O(n³)</a></li>\n<li><a href=\"#ologn\">O(log₂n)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95-%EA%B7%9C%EC%B9%99\">빅오 표기법 규칙</a></p>\n<ul>\n<li><a href=\"#%EA%B3%84%EC%88%98-%EB%B2%95%EC%B9%99\">계수 법칙</a></li>\n<li><a href=\"#%ED%95%A9%EC%9D%98-%EB%B2%95%EC%B9%99\">합의 법칙</a></li>\n<li><a href=\"#%EA%B3%B1%EC%9D%98-%EB%B2%95%EC%B9%99\">곱의 법칙</a></li>\n<li><a href=\"#%EB%8B%A4%ED%95%AD-%EB%B2%95%EC%B9%99-%EB%B9%85%EC%98%A4%EC%9D%98-k%EC%A0%9C%EA%B3%B1\">다항 법칙 (빅오의 k제곱)</a></li>\n</ul>\n</li>\n</ul>"}}]}},"pageContext":{"slug":"/tech/js-algorithm"}},"staticQueryHashes":["2665612806"]}