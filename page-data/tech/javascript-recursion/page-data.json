{"componentChunkName":"component---src-templates-blog-post-js","path":"/tech/javascript-recursion","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"category":"tech","slug":"/tech/javascript-recursion","tags":["자바스크립트"],"date":"2022-08-29","img":null,"title":"자바스크립트에서 재귀함수 사용하기"},"html":"<h2 id=\"재귀recursion란\" style=\"position:relative;\">재귀(Recursion)란<a href=\"#%EC%9E%AC%EA%B7%80recursion%EB%9E%80\" aria-label=\"재귀recursion란 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>재귀란 무엇일까요?<br>\n사전적 정의로 재귀는 <strong>자신을 정의할 때 자기 자신을 재참조하는 방법</strong>입니다.</p>\n<p>자바스크립트에서 재귀 함수란 <strong>자기 자신을 재호출하는 함수</strong> 정도로 설명할 수 있겠네요.</p>\n<p>뭔가 복잡하고 어렵게만 느껴지네요. 비유를 들어보겠습니다.</p>\n<h3 id=\"비유\" style=\"position:relative;\">비유<a href=\"#%EB%B9%84%EC%9C%A0\" aria-label=\"비유 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>옛날 옛적 숫자가 홀수인지 짝수인지 모르던 시절의 한 꼬마 마법사 레미가 살았습니다.</p>\n<p>꼬마 마법사들이 정식 마법사가 되려면 동굴에 사는 정체불명의 그림자 괴물에게 가서 스크롤에 담긴 숫자 중 <strong>홀수</strong>를 알아와야 했습니다.<br>\n한 꼬마 마법사 레미는 스승님에게서 이 과제를 받고 동굴로 떠났습니다.</p>\n<p>스크롤에는 <code class=\"language-text\">[10, 54, 66, 38, 64, 2]</code>라고 적혀있었습니다.</p>\n<p>하지만 막상 레미가 그림자 괴물에게 찾아가 스크롤에 적힌 숫자 중 어떤 게 홀수인지 알려달라 하니, 그림자 괴물은 역정을 내며 절대 알려줄 수 없다고 합니다.</p>\n<p>레미는 협상을 시도하죠.<br>\n<strong>그러면 이 스크롤의 숫자 중, 첫 번째 숫자가 홀수가 아닌지만 알려주세요!</strong></p>\n<p>그림자 괴물은 승낙합니다.</p>\n<p>이윽고 레미가 첫 번째 질문을 했습니다.</p>\n<p><strong>[10, 54, 66, 38, 64, 2] 중 10은 홀수인가요?</strong><br>\n답변은 홀수가 아니었습니다. 홀수가 아니다!</p>\n<p>레미는 골똘히 생각을 했고, 이내 스크롤의 숫자 중 10을 들고 있던 깃펜으로 지운 후 두 번째 질문을 했습니다.</p>\n<p><strong>[54, 66, 38, 64, 2] 중 54는 홀수인가요?</strong><br>\n54또한 홀수가 아니었습니다.</p>\n<p>이렇게 스크롤의 숫자를 차근차근히 지워나간 레미의 스크롤에는 이제 아무런 숫자가 남지 않았습니다.</p>\n<p>레미는 또다시 질문했죠.</p>\n<p><strong>[]의 첫번째 숫자가 홀수인가요?</strong></p>\n<p>그러자 그림자 괴물은 엄청난 화를 내며 그 스크롤은 비어있지 않냐고 멍청이는 썩 꺼지라 말했습니다.</p>\n<p>하지만 이미 레미는 원하는 결과를 얻었죠! 스크롤에는 홀수가 하나도 없었습니다.</p>\n<hr>\n<h3 id=\"예시\" style=\"position:relative;\">예시<a href=\"#%EC%98%88%EC%8B%9C\" aria-label=\"예시 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>앞선 비유가 이해되셨나요?<br>\n똑같은 동작(함수)를 목적을 달성할 때까지(배열이 빌 때까지) <strong>반복</strong>했죠?</p>\n<p>이렇게 특정 조건 하에 함수 자신을 계속해서 참조하는 것이 재귀입니다.</p>\n<p>코드를 한번 살펴볼까요?</p>\n<p>소스를 복사한 후 snippet 등에서 breakpoint를 걸고 참고해보세요.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function findOdd(nums) {\r\n  let result = []\r\n  if (nums.length === 0) {\r\n    return result\r\n  }\r\n  if (nums[0] % 2 === 1) {\r\n    result.push(nums[0])\r\n  }\r\n  return result.concat(findOdd(nums.slice(1)))\r\n}\r\n\r\nfindOdd([10, 54, 66, 38, 64, 2])</code>\n        </deckgo-highlight-code>\n<br/>\n<h4 id=\"참고---snippet-실행-영상\" style=\"position:relative;\">참고 - snippet 실행 영상<a href=\"#%EC%B0%B8%EA%B3%A0---snippet-%EC%8B%A4%ED%96%89-%EC%98%81%EC%83%81\" aria-label=\"참고   snippet 실행 영상 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<video width=\"100%\" controls=\"controls\">\r\n    <source src=\"https://user-images.githubusercontent.com/76241233/187861698-54e4534b-81e0-4217-8b64-7e287299189c.mp4\" type=\"video/mp4\">\r\n</video>\n<br/>\r\n<br/>\r\n<hr/>\n<h2 id=\"재귀를-사용하는-이유\" style=\"position:relative;\">재귀를 사용하는 이유<a href=\"#%EC%9E%AC%EA%B7%80%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"재귀를 사용하는 이유 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>꼭 재귀를 사용하지 않아도 되고, 어떤 경우에는 재귀를 사용하지 않는 것이 더욱 깔끔할 때가 있습니다.\r\n재귀를 사용하는 이유는 여러가지가 있습니다.</p>\n<h3 id=\"재귀를-흔하게-사용하는-경우\" style=\"position:relative;\">재귀를 흔하게 사용하는 경우<a href=\"#%EC%9E%AC%EA%B7%80%EB%A5%BC-%ED%9D%94%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"재귀를 흔하게 사용하는 경우 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>JSON.parse</li>\n<li>JSON.stringify</li>\n<li>document.getElementById</li>\n<li>DOM 순회 알고리즘</li>\n</ul>\n<p>같은 걸 사용할 때는 보통 재귀적으로 작성됩니다.</p>\n<p><code class=\"language-text\">DOM</code>은 중첩된 tree 구조로 되어 있습니다. <code class=\"language-text\">div</code>속에 <code class=\"language-text\">div</code>가 들어있는 중첩 레이어가 100개, 1000개가 될 수도 있습니다. 그 속을 살펴볼 때 흔하게 사용하는 방법 중 하나가 재귀적으로 움직이는 코드를 작성하는 것입니다.</p>\n<h3 id=\"재귀의-장점\" style=\"position:relative;\">재귀의 장점<a href=\"#%EC%9E%AC%EA%B7%80%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"재귀의 장점 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>재귀적 표현이 자연스러울 때 적합\n<ul>\n<li>팩토리얼이나 피보나치 등</li>\n</ul>\n</li>\n<li>변수사용을 줄임\n<ul>\n<li>함수의 단순화</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"재귀를-쓰지-맙시다\" style=\"position:relative;\">재귀를 쓰지 맙시다<a href=\"#%EC%9E%AC%EA%B7%80%EB%A5%BC-%EC%93%B0%EC%A7%80-%EB%A7%99%EC%8B%9C%EB%8B%A4\" aria-label=\"재귀를 쓰지 맙시다 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>종료 조건으로 수렴하지 않을 때</li>\n</ul>\n<p>for 구문을 사용할 때 <strong>무한 루프</strong>에 빠지게 된다면 브라우저가 먹통이 되겠죠?</p>\n<p>재귀도 마찬가지입니다.</p>\n<p>함수에 입력되는 입력값이 변하지 않고 그대로거나, 종료조건이 없거나, 스택 메모리를 초과하여 호출하는 경우에는 재귀를 사용하지 않는 것이 좋습니다.</p>\n<p>위에 작성했던 함수의 일부 코드를 주석처리해보겠습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function findOdd(nums) {\r\n  let result = []\r\n  // if (nums.length === 0) {\r\n  //     return result;\r\n  // }\r\n  if (nums[0] % 2 === 1) {\r\n    result.push(nums[0])\r\n  }\r\n  return result.concat(findOdd(nums.slice(1)))\r\n}\r\n\r\nfindOdd([10, 54, 66, 38, 64, 2]) // Uncaught RangeError: Maximum call stack size exceeded</code>\n        </deckgo-highlight-code>\n<p>바로 <code class=\"language-text\">Maximum call stack size exceeded</code>에러가 발생했습니다.</p>\n<p>호출 스택의 메모리를 초과해버렸다는 것이죠.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">if (nums.length === 0) {\r\n    return result;\r\n}</code>\n        </deckgo-highlight-code>\n<p>이 부분이 바로 재귀 함수의 종료 조건이었음을 알 수 있습니다.<br>\n이미 <code class=\"language-text\">result</code> 배열은 길이가 0이지만 계속해서 slice 처리를 하고, 또 함수를 호출하게 된 것입니다.</p>\n<h2 id=\"재귀함수-작성-시-tips\" style=\"position:relative;\">재귀함수 작성 시 Tips<a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98-%EC%9E%91%EC%84%B1-%EC%8B%9C-tips\" aria-label=\"재귀함수 작성 시 tips permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>종료조건을 먼저 생각하자</li>\n<li>array 가 input값인 경우에는 slice나 spread 연산자, concat 연산자 사용이 유용하다</li>\n<li>string 인 경우에는 slice, substr, substring이 string input값을 복사하기 유용하다</li>\n<li>object 인 경우는 Object.assign이나 spread 연산자가 유용하다</li>\n</ul>","internal":{"content":"\r\n## 재귀(Recursion)란\r\n\r\n재귀란 무엇일까요?  \r\n사전적 정의로 재귀는 **자신을 정의할 때 자기 자신을 재참조하는 방법**입니다.\r\n\r\n자바스크립트에서 재귀 함수란 **자기 자신을 재호출하는 함수** 정도로 설명할 수 있겠네요.\r\n\r\n뭔가 복잡하고 어렵게만 느껴지네요. 비유를 들어보겠습니다.\r\n\r\n### 비유\r\n\r\n옛날 옛적 숫자가 홀수인지 짝수인지 모르던 시절의 한 꼬마 마법사 레미가 살았습니다.\r\n\r\n꼬마 마법사들이 정식 마법사가 되려면 동굴에 사는 정체불명의 그림자 괴물에게 가서 스크롤에 담긴 숫자 중 **홀수**를 알아와야 했습니다.  \r\n한 꼬마 마법사 레미는 스승님에게서 이 과제를 받고 동굴로 떠났습니다.\r\n\r\n스크롤에는 `[10, 54, 66, 38, 64, 2]`라고 적혀있었습니다.\r\n\r\n하지만 막상 레미가 그림자 괴물에게 찾아가 스크롤에 적힌 숫자 중 어떤 게 홀수인지 알려달라 하니, 그림자 괴물은 역정을 내며 절대 알려줄 수 없다고 합니다.\r\n\r\n레미는 협상을 시도하죠.  \r\n**그러면 이 스크롤의 숫자 중, 첫 번째 숫자가 홀수가 아닌지만 알려주세요!**\r\n\r\n그림자 괴물은 승낙합니다.\r\n\r\n이윽고 레미가 첫 번째 질문을 했습니다.\r\n\r\n**[10, 54, 66, 38, 64, 2] 중 10은 홀수인가요?**  \r\n답변은 홀수가 아니었습니다. 홀수가 아니다!\r\n\r\n레미는 골똘히 생각을 했고, 이내 스크롤의 숫자 중 10을 들고 있던 깃펜으로 지운 후 두 번째 질문을 했습니다.\r\n\r\n**[54, 66, 38, 64, 2] 중 54는 홀수인가요?**  \r\n54또한 홀수가 아니었습니다.\r\n\r\n이렇게 스크롤의 숫자를 차근차근히 지워나간 레미의 스크롤에는 이제 아무런 숫자가 남지 않았습니다.\r\n\r\n레미는 또다시 질문했죠.\r\n\r\n**[]의 첫번째 숫자가 홀수인가요?**\r\n\r\n그러자 그림자 괴물은 엄청난 화를 내며 그 스크롤은 비어있지 않냐고 멍청이는 썩 꺼지라 말했습니다.\r\n\r\n하지만 이미 레미는 원하는 결과를 얻었죠! 스크롤에는 홀수가 하나도 없었습니다.\r\n\r\n---\r\n\r\n### 예시\r\n\r\n앞선 비유가 이해되셨나요?  \r\n똑같은 동작(함수)를 목적을 달성할 때까지(배열이 빌 때까지) **반복**했죠?\r\n\r\n이렇게 특정 조건 하에 함수 자신을 계속해서 참조하는 것이 재귀입니다.\r\n\r\n코드를 한번 살펴볼까요?\r\n\r\n소스를 복사한 후 snippet 등에서 breakpoint를 걸고 참고해보세요.\r\n\r\n```javascript\r\nfunction findOdd(nums) {\r\n  let result = []\r\n  if (nums.length === 0) {\r\n    return result\r\n  }\r\n  if (nums[0] % 2 === 1) {\r\n    result.push(nums[0])\r\n  }\r\n  return result.concat(findOdd(nums.slice(1)))\r\n}\r\n\r\nfindOdd([10, 54, 66, 38, 64, 2])\r\n```\r\n\r\n<br/>\r\n\r\n#### 참고 - snippet 실행 영상\r\n\r\n<video width=\"100%\" controls=\"controls\">\r\n    <source src=\"https://user-images.githubusercontent.com/76241233/187861698-54e4534b-81e0-4217-8b64-7e287299189c.mp4\" type=\"video/mp4\">\r\n</video>\r\n\r\n<br/>\r\n<br/>\r\n<hr/>\r\n\r\n## 재귀를 사용하는 이유\r\n\r\n꼭 재귀를 사용하지 않아도 되고, 어떤 경우에는 재귀를 사용하지 않는 것이 더욱 깔끔할 때가 있습니다.\r\n재귀를 사용하는 이유는 여러가지가 있습니다.\r\n\r\n### 재귀를 흔하게 사용하는 경우\r\n\r\n- JSON.parse\r\n- JSON.stringify\r\n- document.getElementById\r\n- DOM 순회 알고리즘\r\n\r\n같은 걸 사용할 때는 보통 재귀적으로 작성됩니다.\r\n\r\n`DOM`은 중첩된 tree 구조로 되어 있습니다. `div`속에 `div`가 들어있는 중첩 레이어가 100개, 1000개가 될 수도 있습니다. 그 속을 살펴볼 때 흔하게 사용하는 방법 중 하나가 재귀적으로 움직이는 코드를 작성하는 것입니다.\r\n\r\n### 재귀의 장점\r\n\r\n- 재귀적 표현이 자연스러울 때 적합\r\n  - 팩토리얼이나 피보나치 등\r\n- 변수사용을 줄임\r\n  - 함수의 단순화\r\n\r\n### 재귀를 쓰지 맙시다\r\n\r\n- 종료 조건으로 수렴하지 않을 때\r\n\r\nfor 구문을 사용할 때 **무한 루프**에 빠지게 된다면 브라우저가 먹통이 되겠죠?\r\n\r\n재귀도 마찬가지입니다.\r\n\r\n함수에 입력되는 입력값이 변하지 않고 그대로거나, 종료조건이 없거나, 스택 메모리를 초과하여 호출하는 경우에는 재귀를 사용하지 않는 것이 좋습니다.\r\n\r\n위에 작성했던 함수의 일부 코드를 주석처리해보겠습니다.\r\n\r\n```javascript\r\nfunction findOdd(nums) {\r\n  let result = []\r\n  // if (nums.length === 0) {\r\n  //     return result;\r\n  // }\r\n  if (nums[0] % 2 === 1) {\r\n    result.push(nums[0])\r\n  }\r\n  return result.concat(findOdd(nums.slice(1)))\r\n}\r\n\r\nfindOdd([10, 54, 66, 38, 64, 2]) // Uncaught RangeError: Maximum call stack size exceeded\r\n```\r\n\r\n바로 `Maximum call stack size exceeded`에러가 발생했습니다.\r\n\r\n호출 스택의 메모리를 초과해버렸다는 것이죠.\r\n\r\n```\r\nif (nums.length === 0) {\r\n    return result;\r\n}\r\n```\r\n\r\n이 부분이 바로 재귀 함수의 종료 조건이었음을 알 수 있습니다.  \r\n이미 `result` 배열은 길이가 0이지만 계속해서 slice 처리를 하고, 또 함수를 호출하게 된 것입니다.\r\n\r\n## 재귀함수 작성 시 Tips\r\n\r\n- 종료조건을 먼저 생각하자\r\n- array 가 input값인 경우에는 slice나 spread 연산자, concat 연산자 사용이 유용하다\r\n- string 인 경우에는 slice, substr, substring이 string input값을 복사하기 유용하다\r\n- object 인 경우는 Object.assign이나 spread 연산자가 유용하다\r\n"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9E%AC%EA%B7%80recursion%EB%9E%80\">재귀(Recursion)란</a></p>\n<ul>\n<li>\n<p><a href=\"#%EB%B9%84%EC%9C%A0\">비유</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%98%88%EC%8B%9C\">예시</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0---snippet-%EC%8B%A4%ED%96%89-%EC%98%81%EC%83%81\">참고 - snippet 실행 영상</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%AC%EA%B7%80%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">재귀를 사용하는 이유</a></p>\n<ul>\n<li><a href=\"#%EC%9E%AC%EA%B7%80%EB%A5%BC-%ED%9D%94%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\">재귀를 흔하게 사용하는 경우</a></li>\n<li><a href=\"#%EC%9E%AC%EA%B7%80%EC%9D%98-%EC%9E%A5%EC%A0%90\">재귀의 장점</a></li>\n<li><a href=\"#%EC%9E%AC%EA%B7%80%EB%A5%BC-%EC%93%B0%EC%A7%80-%EB%A7%99%EC%8B%9C%EB%8B%A4\">재귀를 쓰지 맙시다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98-%EC%9E%91%EC%84%B1-%EC%8B%9C-tips\">재귀함수 작성 시 Tips</a></p>\n</li>\n</ul>"}}]}},"pageContext":{"slug":"/tech/javascript-recursion"}},"staticQueryHashes":["2665612806"]}