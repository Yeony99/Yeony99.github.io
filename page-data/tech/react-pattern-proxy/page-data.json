{"componentChunkName":"component---src-templates-blog-post-js","path":"/tech/react-pattern-proxy","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"category":"tech","slug":"/tech/react-pattern-proxy","tags":["Book"],"date":"2022-09-22","img":null,"title":"[React Patterns] 프록시 패턴"},"excerpt":"프록시 패턴 (Proxy Pattern)  단어의 뜻은 대리인입니다. Proxy 단어 뜻 - 네이버 사전 Proxy 패턴은 실제 객체에 직접 접근하는 것이 아닌, 실 객체를 대리하는 객체인 Proxy 객체를 다루는 패턴입니다. Proxy…","html":"<h2 id=\"프록시-패턴-proxy-pattern\" style=\"position:relative;\">프록시 패턴 (Proxy Pattern)<a href=\"#%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-proxy-pattern\" aria-label=\"프록시 패턴 proxy pattern permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">proxy</code> 단어의 뜻은 <strong>대리인</strong>입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/76241233/191401927-69d5773e-a6ef-467f-96b8-5aa3ee883097.png\" alt=\"Proxy 단어 뜻 - 네이버 사전\"></p>\n<div style=\"font-size: 0.7rem; text-align: end\">출처 : 네이버 사전</div><br/>\n<p>Proxy 패턴은 실제 객체에 직접 접근하는 것이 아닌, 실 객체를 대리하는 객체인 Proxy 객체를 다루는 패턴입니다.</p>\n<h3 id=\"proxy-객체와-상호작용하기\" style=\"position:relative;\">Proxy 객체와 상호작용하기<a href=\"#proxy-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%83%81%ED%98%B8%EC%9E%91%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"proxy 객체와 상호작용하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>먼저 객체를 만들고 그 객체의 Proxy 객체를 만들어봅시다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const person = {\r\n  name: &quot;yeony&quot;,\r\n  age: 24,\r\n  job: &quot;frontend developer&quot;,\r\n}\r\n\r\n//Proxy 객체\r\nconst personProxy = new Proxy(person, {})</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Proxy</code>객체는 프록시 인스턴스 생성(new 키워드)으로 쉽게 만들 수 있습니다.</p>\n<h3 id=\"proxy-객체-살펴보기\" style=\"position:relative;\">Proxy 객체 살펴보기<a href=\"#proxy-%EA%B0%9D%EC%B2%B4-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"proxy 객체 살펴보기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Proxy</code> 클래스의 구조를 살펴봅시다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">new Proxy(target, handler)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Proxy</code>의 첫 번째 매개변수는 프록시객체로 만들 타깃 객체입니다.<br>\n두 번째 매개변수는 <code class=\"language-text\">핸들러</code>로, proxy의 행동을 정의합니다.</p>\n<p>핸들러 객체에서 인터랙션 동작을 정의하고, 메소드를 추가할 수 있습니다.</p>\n<p>가장 흔히 사용되는 메소드인 <code class=\"language-text\">get</code>과 <code class=\"language-text\">set</code> 메소드를 보겠습니다.</p>\n<ul>\n<li>get : 프로퍼티에 접근하려 할 때 실행</li>\n<li>set : 프로퍼티에 값을 수정하려 할 때 실행</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const person = {\r\n  name: &quot;yeony&quot;,\r\n  age: 24,\r\n  job: &quot;frontend developer&quot;,\r\n}\r\n\r\n//Proxy 객체\r\nconst personProxy = new Proxy(person, {\r\n  get: (obj, prop) =&gt; {\r\n    console.log(`The value of ${prop} is ${obj[prop]}`)\r\n  },\r\n  set: (obj, prop, value) =&gt; {\r\n    console.log(`Changed ${prop} from ${obj[prop]} to ${value}`)\r\n    obj[prop] = value\r\n    return true\r\n  },\r\n})\r\n\r\npersonProxy.name = &quot;Nayeon&quot;</code>\n        </deckgo-highlight-code>\n<p>이렇게 되면 <code class=\"language-text\">personProxy</code>를 통해 <code class=\"language-text\">person</code>객체가 수정됩니다.</p>\n<h3 id=\"유효성-검사\" style=\"position:relative;\">유효성 검사<a href=\"#%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC\" aria-label=\"유효성 검사 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이러한 프록시 패턴은 유효성 검사를 구현할 때 유용하게 사용할 수 있습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const personProxy = new Proxy(person, {\r\n  get: (obj, prop) =&gt; {\r\n    // 원본 person 객체에 key가 존재하지 않으면 접근할 수 없도록 방지\r\n    if (!obj[prop]) {\r\n      console.log(\r\n        `Hmm.. this property doesn&#39;t seem to exist on the target object`\r\n      )\r\n    } else {\r\n      console.log(`The value of ${prop} is ${obj[prop]}`)\r\n    }\r\n  },\r\n  set: (obj, prop, value) =&gt; {\r\n    // 타입이나 제약을 추가하여 변경 시 안정성 보장\r\n    if (prop === &quot;age&quot; &amp;&amp; typeof value !== &quot;number&quot;) {\r\n      console.log(`Sorry, you can only pass numeric values for age.`)\r\n    } else if (prop === &quot;name&quot; &amp;&amp; value.length &lt; 2) {\r\n      console.log(`You need to provide a valid name.`)\r\n    } else {\r\n      console.log(`Changed ${prop} from ${obj[prop]} to ${value}.`)\r\n      obj[prop] = value\r\n    }\r\n  },\r\n})</code>\n        </deckgo-highlight-code>\n<p>원본 객체에 존재하지 않는 key로 접근하거나, 예상하지 못한 타입의 값을 할당하려는 경우에 proxy객체를 통해 방지할 수 있습니다. 따라서 실수를 예방함으로써 <strong>데이터의 안정성</strong>을 관리할 수 있는 패턴이 됩니다.</p>\n<h3 id=\"reflect\" style=\"position:relative;\">Reflect<a href=\"#reflect\" aria-label=\"reflect permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자바스크립트에서는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\">Reflect</a> 라는 빌트인 객체를 제공합니다.</p>\n<p><code class=\"language-text\">Reflect</code>는 중간에서 가로챌 수 있는 자바스크립트 작업에 대한 메소드를 제공합니다. 메소드 종류는 <code class=\"language-text\">Proxy</code>와 동일합니다. 단, 함수 객체가 아니라 생성자로 사용은 불가능합니다.</p>\n<p><code class=\"language-text\">Reflect</code>는 이렇게 사용합니다</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// Proxy\r\nconst personProxy = new Proxy(person, {\r\n  get: (obj, prop) =&gt; {\r\n    console.log(`The value of ${prop} is ${obj[prop]}`)\r\n  },\r\n  set: (obj, prop, value) =&gt; {\r\n    console.log(`Changed ${prop} from ${obj[prop]} to ${value}`)\r\n    obj[prop] = value\r\n  },\r\n})\r\n\r\n// Reflect 사용\r\nconst personProxy = new Proxy(person, {\r\n  get: (obj, prop) =&gt; {\r\n    console.log(`The value of ${prop} is ${Reflect.get(obj, prop)}`)\r\n  },\r\n  set: (obj, prop, value) =&gt; {\r\n    console.log(`Changed ${prop} from ${obj[prop]} to ${value}`)\r\n    Reflect.set(obj, prop, value)\r\n  },\r\n})</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">obj[prop] = value</code> 형태가 아니라, <code class=\"language-text\">Reflect.get(obj, prop)</code>, <code class=\"language-text\">Reflect.set(obj, prop, value)</code>의 형태로 작성할 수 있습니다.</p>\n<h2 id=\"결론\" style=\"position:relative;\">결론<a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Proxy는 객체의 동작을 커스터마이징할 수 있는 유용한 기능입니다. 유효성 검사, formatting, 알림, 디버깅 등에 유용합니다.</p>\n<p>핸들러 객체에서 Proxy를 과도하게 사용하면 성능이 저하될 수 있습니다.</p>","internal":{"content":"\r\n## 프록시 패턴 (Proxy Pattern)\r\n\r\n`proxy` 단어의 뜻은 **대리인**입니다.\r\n\r\n![Proxy 단어 뜻 - 네이버 사전](https://user-images.githubusercontent.com/76241233/191401927-69d5773e-a6ef-467f-96b8-5aa3ee883097.png)\r\n\r\n<div style=\"font-size: 0.7rem; text-align: end\">출처 : 네이버 사전</div><br/>\r\n\r\nProxy 패턴은 실제 객체에 직접 접근하는 것이 아닌, 실 객체를 대리하는 객체인 Proxy 객체를 다루는 패턴입니다.\r\n\r\n### Proxy 객체와 상호작용하기\r\n\r\n먼저 객체를 만들고 그 객체의 Proxy 객체를 만들어봅시다.\r\n\r\n```javascript\r\nconst person = {\r\n  name: \"yeony\",\r\n  age: 24,\r\n  job: \"frontend developer\",\r\n}\r\n\r\n//Proxy 객체\r\nconst personProxy = new Proxy(person, {})\r\n```\r\n\r\n`Proxy`객체는 프록시 인스턴스 생성(new 키워드)으로 쉽게 만들 수 있습니다.\r\n\r\n### Proxy 객체 살펴보기\r\n\r\n`Proxy` 클래스의 구조를 살펴봅시다.\r\n\r\n```javascript\r\nnew Proxy(target, handler)\r\n```\r\n\r\n`Proxy`의 첫 번째 매개변수는 프록시객체로 만들 타깃 객체입니다.  \r\n두 번째 매개변수는 `핸들러`로, proxy의 행동을 정의합니다.\r\n\r\n핸들러 객체에서 인터랙션 동작을 정의하고, 메소드를 추가할 수 있습니다.\r\n\r\n가장 흔히 사용되는 메소드인 `get`과 `set` 메소드를 보겠습니다.\r\n\r\n- get : 프로퍼티에 접근하려 할 때 실행\r\n- set : 프로퍼티에 값을 수정하려 할 때 실행\r\n\r\n```javascript\r\nconst person = {\r\n  name: \"yeony\",\r\n  age: 24,\r\n  job: \"frontend developer\",\r\n}\r\n\r\n//Proxy 객체\r\nconst personProxy = new Proxy(person, {\r\n  get: (obj, prop) => {\r\n    console.log(`The value of ${prop} is ${obj[prop]}`)\r\n  },\r\n  set: (obj, prop, value) => {\r\n    console.log(`Changed ${prop} from ${obj[prop]} to ${value}`)\r\n    obj[prop] = value\r\n    return true\r\n  },\r\n})\r\n\r\npersonProxy.name = \"Nayeon\"\r\n```\r\n\r\n이렇게 되면 `personProxy`를 통해 `person`객체가 수정됩니다.\r\n\r\n### 유효성 검사\r\n\r\n이러한 프록시 패턴은 유효성 검사를 구현할 때 유용하게 사용할 수 있습니다.\r\n\r\n```javascript\r\nconst personProxy = new Proxy(person, {\r\n  get: (obj, prop) => {\r\n    // 원본 person 객체에 key가 존재하지 않으면 접근할 수 없도록 방지\r\n    if (!obj[prop]) {\r\n      console.log(\r\n        `Hmm.. this property doesn't seem to exist on the target object`\r\n      )\r\n    } else {\r\n      console.log(`The value of ${prop} is ${obj[prop]}`)\r\n    }\r\n  },\r\n  set: (obj, prop, value) => {\r\n    // 타입이나 제약을 추가하여 변경 시 안정성 보장\r\n    if (prop === \"age\" && typeof value !== \"number\") {\r\n      console.log(`Sorry, you can only pass numeric values for age.`)\r\n    } else if (prop === \"name\" && value.length < 2) {\r\n      console.log(`You need to provide a valid name.`)\r\n    } else {\r\n      console.log(`Changed ${prop} from ${obj[prop]} to ${value}.`)\r\n      obj[prop] = value\r\n    }\r\n  },\r\n})\r\n```\r\n\r\n원본 객체에 존재하지 않는 key로 접근하거나, 예상하지 못한 타입의 값을 할당하려는 경우에 proxy객체를 통해 방지할 수 있습니다. 따라서 실수를 예방함으로써 **데이터의 안정성**을 관리할 수 있는 패턴이 됩니다.\r\n\r\n### Reflect\r\n\r\n자바스크립트에서는 [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect) 라는 빌트인 객체를 제공합니다.\r\n\r\n`Reflect`는 중간에서 가로챌 수 있는 자바스크립트 작업에 대한 메소드를 제공합니다. 메소드 종류는 `Proxy`와 동일합니다. 단, 함수 객체가 아니라 생성자로 사용은 불가능합니다.\r\n\r\n`Reflect`는 이렇게 사용합니다\r\n\r\n```javascript\r\n// Proxy\r\nconst personProxy = new Proxy(person, {\r\n  get: (obj, prop) => {\r\n    console.log(`The value of ${prop} is ${obj[prop]}`)\r\n  },\r\n  set: (obj, prop, value) => {\r\n    console.log(`Changed ${prop} from ${obj[prop]} to ${value}`)\r\n    obj[prop] = value\r\n  },\r\n})\r\n\r\n// Reflect 사용\r\nconst personProxy = new Proxy(person, {\r\n  get: (obj, prop) => {\r\n    console.log(`The value of ${prop} is ${Reflect.get(obj, prop)}`)\r\n  },\r\n  set: (obj, prop, value) => {\r\n    console.log(`Changed ${prop} from ${obj[prop]} to ${value}`)\r\n    Reflect.set(obj, prop, value)\r\n  },\r\n})\r\n```\r\n\r\n`obj[prop] = value` 형태가 아니라, `Reflect.get(obj, prop)`, `Reflect.set(obj, prop, value)`의 형태로 작성할 수 있습니다.\r\n\r\n## 결론\r\n\r\nProxy는 객체의 동작을 커스터마이징할 수 있는 유용한 기능입니다. 유효성 검사, formatting, 알림, 디버깅 등에 유용합니다.\r\n\r\n핸들러 객체에서 Proxy를 과도하게 사용하면 성능이 저하될 수 있습니다.\r\n"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4-proxy-pattern\">프록시 패턴 (Proxy Pattern)</a></p>\n<ul>\n<li><a href=\"#proxy-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%83%81%ED%98%B8%EC%9E%91%EC%9A%A9%ED%95%98%EA%B8%B0\">Proxy 객체와 상호작용하기</a></li>\n<li><a href=\"#proxy-%EA%B0%9D%EC%B2%B4-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0\">Proxy 객체 살펴보기</a></li>\n<li><a href=\"#%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC\">유효성 검사</a></li>\n<li><a href=\"#reflect\">Reflect</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n</li>\n</ul>"}}]}},"pageContext":{"slug":"/tech/react-pattern-proxy"}},"staticQueryHashes":["2665612806"]}