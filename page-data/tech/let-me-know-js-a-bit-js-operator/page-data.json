{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/tech/let-me-know-js-a-bit-js-operator",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"category":"tech","slug":"/tech/let-me-know-js-a-bit-js-operator","tags":["쫌만알자"],"date":"2022-09-28","img":"https://user-images.githubusercontent.com/76241233/177932893-5a504b26-12e4-4ade-b1ce-1951d072ba82.jpg","title":"쫌만알자! (10) - 자바스크립트 연산자"},"html":"<h2 id=\"연산자operator란\" style=\"position:relative;\">연산자(Operator)란?<a href=\"#%EC%97%B0%EC%82%B0%EC%9E%90operator%EB%9E%80\" aria-label=\"연산자operator란 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>연산자란 문장 부호 혹은 영어, 숫자로 구성된 <strong>예약된 구문</strong>입니다.</p>\n<p><code class=\"language-text\">+</code>라는 기호는 숫자를 추가하거나 문자열을 연결할 수 있게 하고, <code class=\"language-text\">&lt;</code> 기호는 좌항과 우항의 값을 비교합니다.</p>\n<p>이러한 연산자는 여러 종류로 분류할 수 있습니다.</p>\n<h3 id=\"산술-연산자-arithmetic-operator\" style=\"position:relative;\">산술 연산자 (Arithmetic Operator)<a href=\"#%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90-arithmetic-operator\" aria-label=\"산술 연산자 arithmetic operator permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><strong>연산</strong>이라고 하면 가장 먼저 사칙연산이 떠오릅니다. 자바스크립트 또한 이런 산술적인 연산을 제공합니다. 사칙연산은 우리가 흔히 아는 기호(+, -, *, /)와 동일하게 움직입니다.</p>\n<p>산술 연산자는 2가지로 나뉩니다.</p>\n<h4 id=\"이항-산술-연산자-binary-operator\" style=\"position:relative;\">이항 산술 연산자 (Binary Operator)<a href=\"#%EC%9D%B4%ED%95%AD-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90-binary-operator\" aria-label=\"이항 산술 연산자 binary operator permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><strong>이항</strong>이라는 말은 항이 2개가 있다는 의미입니다. <code class=\"language-text\">x + y</code>는 연산되는 대상인 피연산자가 2개이죠? 그래서 이항(binary) 산술 연산자입니다.</p>\n<table>\n    <tr>\n        <th>연산자</td>\n        <th>동작</td>\n    </tr>\n    <tr>\n        <td>+</td>\n        <td>덧셈</td>\n    </tr>\n    <tr>\n        <td>-</td>\n        <td>뺄셈</td>\n    </tr>\n    <tr>\n        <td>*</td>\n        <td>곱셈</td>\n    </tr>\n    <tr>\n        <td>/</td>\n        <td>나눗셈</td>\n    </tr>\n    <tr>\n        <td>%</td>\n        <td>나머지</td>\n    </tr>\n</table>\n<br/>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">5 + 2 // 7\n5 - 2 // 3\n5 * 2 // 10\n5 / 2 // 2.5\n5 % 2 // 1</code>\n        </deckgo-highlight-code>\n<h4 id=\"단항-산술-연산자-unary-operator\" style=\"position:relative;\">단항 산술 연산자 (Unary Operator)<a href=\"#%EB%8B%A8%ED%95%AD-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90-unary-operator\" aria-label=\"단항 산술 연산자 unary operator permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>이항 연산자와 달리 단항 산술 연산자는 1개의 피연산자만이 존재합니다.</p>\n<p>조금 낯선 모양일 수 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>동작</th>\n<th>부수효과</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>++</td>\n<td>증가</td>\n<td>피연산자의 값을 변경</td>\n</tr>\n<tr>\n<td>--</td>\n<td>감소</td>\n<td>피연산자의 값을 변경</td>\n</tr>\n<tr>\n<td>+</td>\n<td>숫자타입에는 효과없음. <br/>숫자타입으로 변환될 수 있는 경우 변환된 값 반환</td>\n<td></td>\n</tr>\n<tr>\n<td>-</td>\n<td>양수를 음수로, 음수를 양수로 반전</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let x = 1\n\nx++ // 2\nx-- // 1\n\nconsole.log(-x) // -1</code>\n        </deckgo-highlight-code>\n<p>여기서 증가/감소 연산자는 피연산자의 앞에 붙는지, 뒤에 붙는지에 따라 동작하는 시점에 차이가 있습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let x = 10\nlet result\n\n// 선할당 후증가(postfix increment operator)\nresult = x++\nconsole.log(result, x) // 10, 11\n\n// 선증가 후할당(prefix increment operator)\nresult = ++x\nconsole.log(result, x) // 12 12\n\n// 선할당 후감소(postfix decrement operator)\nresult = x--\nconsole.log(result, x) // 12 11\n\n// 선감소 후할당(prefix decrement operator)\nresult = --x\nconsole.log(result, x) // 10 10</code>\n        </deckgo-highlight-code>\n<p>조금 복잡하죠? 사실 저는 이런 증가/감소 단항 연산자는 잘 사용하지 않습니다. 잘못된 연산이 될 수도 있고, 처음 값을 할당한 변수의 값이 계속 바뀌기 때문이죠. 그래서 아래와 같은 방식을 추천합니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let x = 10\nlet result\n\nresult = x + 1\nconsole.log(result, x) // 11, 10\n\nresult = x - 1\nconsole.log(result, x) // 10, 10</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">x</code>의 값은 변하지 않고 <code class=\"language-text\">result</code>값만 계속 변화합니다. 만약 <code class=\"language-text\">x</code>가 내부적으로 계산되는 임시 변수가 아니라 함수의 인자 등으로 처음 넘겨받은 값이라면 변하지 않는 것이 더욱 좋을 것입니다.</p>\n<h4 id=\"문자열-연결-연산자\" style=\"position:relative;\">문자열 연결 연산자<a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%B0%EA%B2%B0-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"문자열 연결 연산자 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">+</code> 연산자는 피연산자 중 문자열이 하나라도 존재할 때 문자열로 형변환하여 연결합니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">1 + &quot;1&quot; // 11\n1 + &quot;1&quot; + 1 + 0 // 1110\n\n// true는 1로, false는 0으로 변환\n1 + true // 2\n1 + false // 1\n\n// null은 0으로 변환\n1 + null // 1\n\n// undefined는 정의되지 않았기 때문에\n// 숫자로 변환되지 않음\n1 + undefined // NaN\n\n// 문자열에 + 붙이면 숫자타입으로 변환\n1 + &quot;1&quot; // 2</code>\n        </deckgo-highlight-code>\n<br/>\n<hr>\n<h3 id=\"할당-연산자-assignment-operator\" style=\"position:relative;\">할당 연산자 (Assignment Operator)<a href=\"#%ED%95%A0%EB%8B%B9-%EC%97%B0%EC%82%B0%EC%9E%90-assignment-operator\" aria-label=\"할당 연산자 assignment operator permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>할당 연산자는 우항 피연산자의 평가 결과를 좌항 변수에 할당합니다.</p>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>동작</th>\n<th>부수효과</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>할당</td>\n<td>우항의 표현식 결과 값을 좌항의 변수에 할당</td>\n</tr>\n<tr>\n<td>+=</td>\n<td>x = x + 2</td>\n<td>\"</td>\n</tr>\n<tr>\n<td>-=</td>\n<td>x = x - 2</td>\n<td>\"</td>\n</tr>\n<tr>\n<td>*=</td>\n<td>x = x * 2</td>\n<td>\"</td>\n</tr>\n<tr>\n<td>/=</td>\n<td>x = x / 2</td>\n<td>\"</td>\n</tr>\n<tr>\n<td>%=</td>\n<td>x = x % 2</td>\n<td>\"</td>\n</tr>\n</tbody>\n</table>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">let x = 3\n\nx += 3 // 6\n\nx -= 3 // 3\n\nx *= 3 // 9\n\nx /= 3 // 3\n\nx %= 3 // 0</code>\n        </deckgo-highlight-code>\n<br/>\n<hr>\n<h3 id=\"비교-연산자\" style=\"position:relative;\">비교 연산자<a href=\"#%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"비교 연산자 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>비교 연산자는 좌항과 우항의 피연산자를 비교해 그 값을 불리언(true/false) 타입으로 반환합니다.</p>\n<h4 id=\"동등-비교-연산자-equality-operator\" style=\"position:relative;\">동등 비교 연산자 (Equality Operator)<a href=\"#%EB%8F%99%EB%93%B1-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90-equality-operator\" aria-label=\"동등 비교 연산자 equality operator permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>값이 <strong>동등</strong>한 지를 평가하는 연산자입니다.</p>\n<p>여기서 동등하다는 자바스크립트 엔진이 자체적으로 형변환을 한 후에 비교했을 때에 같다고 평가되었다는 의미입니다.<br>\n자바스크립트는 굉장히 자유로운 언어라고 했죠? 따라서 변수를 할당하면 자체적으로 타입을 추론합니다. 그리고 동등한지를 평가할 때 <strong>암묵적인 타입 변환</strong>을 합니다. 이런 형변환은 이따금 약간의 골칫거리가 되기도 하는데요. 형변환에 대해서는 추후 자세히 다룰 예정입니다. 지금은 자바스크립트가 타입을 추론해 바꾸기도 한다는 점만 알고 가기로 해요.</p>\n<p>예시를 보겠습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">2 == 2 // true\n\n// 암묵적 타입 변환해 타입이 같을 경우에\n2 == &quot;2&quot; // true</code>\n        </deckgo-highlight-code>\n<p>분명 숫자와 문자열을 비교했는데 두 값이 같다고 <code class=\"language-text\">true</code>를 반환하네요.\n동등 비교가 타입을 바꿔서도 검사해주니 좋다고 생각할 수도 있지만, 사실 클린 코드를 작성하는 데에는 취약점입니다. 이미 우리는 앞서 타입 변환이 일어나 <code class=\"language-text\">1 + '1'</code>이 <code class=\"language-text\">11</code>이 되는 걸 확인했죠. 비슷한 예기치 못한 결과를 낳을 수 있기 때문에 <strong>일치 비교 연산자</strong>를 쓰는 것을 권장합니다.</p>\n<h4 id=\"일치-비교-연산자-strict-equality-operator\" style=\"position:relative;\">일치 비교 연산자 (Strict Equality Operator)<a href=\"#%EC%9D%BC%EC%B9%98-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90-strict-equality-operator\" aria-label=\"일치 비교 연산자 strict equality operator permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>일치 비교 연산자는 <strong>타입과 값</strong>이 모두 같을 경우에만 true를 반환합니다. 동등 비교보다 한층 강화된 연산자이기 때문에 <strong>엄격한 동등 연산자</strong>입니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">2 === 2 // true\n\n2 === &quot;2&quot; // false</code>\n        </deckgo-highlight-code>\n<p>일치 비교 연산자로 다 비교할 수 있으면 좋겠지만, 유의해야 할 값이 있습니다. 바로 <code class=\"language-text\">NaN</code>입니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">NaN === NaN // false</code>\n        </deckgo-highlight-code>\n<p>MDN의 설명을 참고하면, <code class=\"language-text\">NaN</code>은 자신과 일치하지 않는 유일한 값입니다 (NaN is the only value that compares unequal to itself). 이건 일종의 버그에</p>\n<p>따라서 <code class=\"language-text\">isNaN()</code></p>\n<h4 id=\"부동등불일치-비교-연산자-inequality--string-inequality-operator\" style=\"position:relative;\">부동등/불일치 비교 연산자 (Inequality / String Inequality Operator)<a href=\"#%EB%B6%80%EB%8F%99%EB%93%B1%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90-inequality--string-inequality-operator\" aria-label=\"부동등불일치 비교 연산자 inequality  string inequality operator permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>동등, 일치가 있다면 동등하지 않은 것과 불일치하는 것도 비교할 수 있어야겠죠?</p>\n<p>자바스크립트에서는 <code class=\"language-text\">!</code> 느낌표를 <strong>NOT</strong> 의미로 사용합니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">1 != 5 // true\n1 !== &quot;1&quot; // true</code>\n        </deckgo-highlight-code>\n<p>동등/일치 연산자에 <code class=\"language-text\">!</code>를 붙여주면, 부동등 연산자는 값이 같지 않을 때, 불일치 연산자는 값과 타입이 모두 같지 않을 때 <code class=\"language-text\">true</code> 값을 리턴합니다.</p>\n<h4 id=\"대소-비교-연산자\" style=\"position:relative;\">대소 비교 연산자<a href=\"#%EB%8C%80%EC%86%8C-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"대소 비교 연산자 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>수학 연산에서 쓰이는 기호와 같습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">1 &gt;= 2 // false\n2 &gt; 1 // true</code>\n        </deckgo-highlight-code>\n<h3 id=\"삼항-연산자-ternary-operator\" style=\"position:relative;\">삼항 연산자 (Ternary Operator)<a href=\"#%EC%82%BC%ED%95%AD-%EC%97%B0%EC%82%B0%EC%9E%90-ternary-operator\" aria-label=\"삼항 연산자 ternary operator permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>삼항 연산자는 자바스크립트에서 유일하게 <strong>3개의 피연산자</strong>를 가지는 연산자입니다.</p>\n<p>삼항 연산자는 조건식의 평가에 따라 반환되는 값이 달라집니다.</p>\n<p>삼항 연산자를 세 부분으로 나누어 살펴보겠습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/76241233/191170567-ccb8f67f-0b77-40d8-8199-7a73eabe51de.png\" alt=\"삼항연산자\"></p>\n<p><code class=\"language-text\">?</code> 전까지는 조건식이 들어갑니다. 조건식의 결과는 Boolean 타입으로 평가되고, 만약 Boolean 타입이 아니라면 암묵적인 형변환을 통해 그 값을 Boolean으로 변환합니다.</p>\n<p>만약 조건식이 <code class=\"language-text\">true</code>라면 <code class=\"language-text\">?</code> 뒤의 값이, <code class=\"language-text\">false</code>라면 <code class=\"language-text\">:</code> 뒤의 값이 삼항연산자의 값으로 평가됩니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function isAdult(age) {\n  return age &gt; 19 ? &quot;You are an adult!&quot; : &quot;You are too young...&quot;\n}\n\nisAdult(15) // &#39;You are too young...&#39;\n\nisAdult(24) // You are an adult!</code>\n        </deckgo-highlight-code>\n<p>삼항 연산자는 <code class=\"language-text\">if...else</code>문과 비슷하다고 생각할 수 있는데요. 유의해야 할 차이점이 있습니다. <code class=\"language-text\">if...else</code>는 <strong>조건문</strong>이고, 삼항 연산자는 <strong>표현식</strong>이란 점입니다.</p>\n<p>이전 글에서 값, 식, 문의 차이를 알아보며 문은 변수에 할당할 수 없지만, 표현식은 값으로 평가되어 할당할 수 있다고 설명한 바가 있습니다. 따라서 값처럼 사용할 수 있는 삼항 연산자는 무척 유용합니다.</p>\n<br/>\n<hr>\n<h3 id=\"논리-연산자-logical-operator\" style=\"position:relative;\">논리 연산자 (Logical Operator)<a href=\"#%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0%EC%9E%90-logical-operator\" aria-label=\"논리 연산자 logical operator permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>논리 연산자는 우항과 좌항의 피연산자를 논리적으로 연산합니다.</p>\n<p>논리적으로 연산한다는 말이 조금 어렵게 느껴집니다. 간단하게 Boolean 연산이라고 생각하면 됩니다. 논리연산은 <code class=\"language-text\">true</code>와 <code class=\"language-text\">false</code>만 존재하는 연산입니다.</p>\n<table>\n<thead>\n<tr>\n<th>연산자</th>\n<th>동작</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>||</td>\n<td>논리합(OR)</td>\n<td>피연산자 중 하나라도 true이면 true</td>\n</tr>\n<tr>\n<td>&#x26;&#x26;</td>\n<td>논리곱(AND)</td>\n<td>피연산자 모두 true여야 true</td>\n</tr>\n<tr>\n<td>!</td>\n<td>논리부정(NOT)</td>\n<td>피연산자의 값을 반전한 값 반환</td>\n</tr>\n</tbody>\n</table>\n<p>이렇게만 봐서는 좀 어렵습니다. 예제를 함께 살펴보겠습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// 논리합 (||)\ntrue || true // true\ntrue || false // true\nfalse || true // true\nfalse || false // false\n\n// 논리곱(&amp;&amp;)\ntrue &amp;&amp; true // true\ntrue &amp;&amp; false // false\nfalse &amp;&amp; true // false\nfalse &amp;&amp; false // false\n\n// 부정 (!)\n!true // false\n!false // true</code>\n        </deckgo-highlight-code>\n<p>논리 부정 연산자(!)는 항상 Boolean값으로 반환되는데, 피연산자의 값이 Boolean이 아니면 Boolean 값으로 암묵적 형변환하여 평가합니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">console.log(!0) // true\nconsole.log(!&quot;Any String&quot;) // false</code>\n        </deckgo-highlight-code>\n<p>논리 곱 연산자(&#x26;&#x26;)는 늘 2개의 피연산자 중 하나로 평가됩니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">console.log(&quot;Apple&quot; &amp;&amp; &quot;Banana&quot;) // Banana</code>\n        </deckgo-highlight-code>\n<br/>\n<hr>\n<h3 id=\"typeof\" style=\"position:relative;\">typeof<a href=\"#typeof\" aria-label=\"typeof permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>typeof 연산자는 이름에서 알 수 있듯 피연산자의 타입을 문자열로 반환합니다.</p>\n<p>typeof 연산자가 반환하는 값의 종류는 다음과 같습니다.</p>\n<ul>\n<li>string</li>\n<li>number</li>\n<li>boolean</li>\n<li>undefined</li>\n<li>symbol</li>\n<li>object</li>\n<li>function</li>\n</ul>\n<p>사실 typeof 로 검사해도 우리가 원하는 타입과 정확히 맞아떨어지는 결과가 반환되지만은 않습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">typeof &quot;&quot; // string (null 예상)\ntypeof NaN // number\ntypeof null // object\ntypeof [] // object\ntypeof new Date() // object</code>\n        </deckgo-highlight-code>\n<p>조금 이상하죠? 특히 <code class=\"language-text\">null</code>을 검사했는데 object로 넘기는 건 정말 이상합니다. 이건 자바스크립트의 버그입니다. 하지만 기존에 이미 작성된 코드와의 호환을 위해 의도적으로 남긴 버그입니다.</p>\n<p>따라서 null을 체크할 때에는 <code class=\"language-text\">===</code>일치 연산자를 사용하는 것이 좋습니다.</p>\n<p>ES6 이후 자바스크립트 스펙에서 추가된 연산자들은 추후 알아보도록 하겠습니다.</p>\n<p>다음 글에서는 제어문에 대해 알아보겠습니다.</p>\n<p>◾ <a href=\"/tech/let-me-know-js-a-bit-js-value-expression-statement\">값, 식, 문</a> 👈 이전 글 보기<br>\n◾ <a href=\"/tech/let-me-know-js-a-bit-js-control-flow-statement-conditional\">제어문(1) - 조건문</a> 👈 다음 글 보기</p>","internal":{"content":"\n## 연산자(Operator)란?\n\n연산자란 문장 부호 혹은 영어, 숫자로 구성된 **예약된 구문**입니다.\n\n`+`라는 기호는 숫자를 추가하거나 문자열을 연결할 수 있게 하고, `<` 기호는 좌항과 우항의 값을 비교합니다.\n\n이러한 연산자는 여러 종류로 분류할 수 있습니다.\n\n### 산술 연산자 (Arithmetic Operator)\n\n**연산**이라고 하면 가장 먼저 사칙연산이 떠오릅니다. 자바스크립트 또한 이런 산술적인 연산을 제공합니다. 사칙연산은 우리가 흔히 아는 기호(+, -, \\*, /)와 동일하게 움직입니다.\n\n산술 연산자는 2가지로 나뉩니다.\n\n#### 이항 산술 연산자 (Binary Operator)\n\n**이항**이라는 말은 항이 2개가 있다는 의미입니다. `x + y`는 연산되는 대상인 피연산자가 2개이죠? 그래서 이항(binary) 산술 연산자입니다.\n\n<table>\n    <tr>\n        <th>연산자</td>\n        <th>동작</td>\n    </tr>\n    <tr>\n        <td>+</td>\n        <td>덧셈</td>\n    </tr>\n    <tr>\n        <td>-</td>\n        <td>뺄셈</td>\n    </tr>\n    <tr>\n        <td>*</td>\n        <td>곱셈</td>\n    </tr>\n    <tr>\n        <td>/</td>\n        <td>나눗셈</td>\n    </tr>\n    <tr>\n        <td>%</td>\n        <td>나머지</td>\n    </tr>\n</table>\n<br/>\n\n```javascript\n5 + 2 // 7\n5 - 2 // 3\n5 * 2 // 10\n5 / 2 // 2.5\n5 % 2 // 1\n```\n\n#### 단항 산술 연산자 (Unary Operator)\n\n이항 연산자와 달리 단항 산술 연산자는 1개의 피연산자만이 존재합니다.\n\n조금 낯선 모양일 수 있습니다.\n\n| 연산자 | 동작                                                                        | 부수효과             |\n| ------ | --------------------------------------------------------------------------- | -------------------- |\n| ++     | 증가                                                                        | 피연산자의 값을 변경 |\n| --     | 감소                                                                        | 피연산자의 값을 변경 |\n| +      | 숫자타입에는 효과없음. <br/>숫자타입으로 변환될 수 있는 경우 변환된 값 반환 |                      |\n| -      | 양수를 음수로, 음수를 양수로 반전                                           | X                    |\n\n```javascript\nlet x = 1\n\nx++ // 2\nx-- // 1\n\nconsole.log(-x) // -1\n```\n\n여기서 증가/감소 연산자는 피연산자의 앞에 붙는지, 뒤에 붙는지에 따라 동작하는 시점에 차이가 있습니다.\n\n```javascript\nlet x = 10\nlet result\n\n// 선할당 후증가(postfix increment operator)\nresult = x++\nconsole.log(result, x) // 10, 11\n\n// 선증가 후할당(prefix increment operator)\nresult = ++x\nconsole.log(result, x) // 12 12\n\n// 선할당 후감소(postfix decrement operator)\nresult = x--\nconsole.log(result, x) // 12 11\n\n// 선감소 후할당(prefix decrement operator)\nresult = --x\nconsole.log(result, x) // 10 10\n```\n\n조금 복잡하죠? 사실 저는 이런 증가/감소 단항 연산자는 잘 사용하지 않습니다. 잘못된 연산이 될 수도 있고, 처음 값을 할당한 변수의 값이 계속 바뀌기 때문이죠. 그래서 아래와 같은 방식을 추천합니다.\n\n```javascript\nlet x = 10\nlet result\n\nresult = x + 1\nconsole.log(result, x) // 11, 10\n\nresult = x - 1\nconsole.log(result, x) // 10, 10\n```\n\n`x`의 값은 변하지 않고 `result`값만 계속 변화합니다. 만약 `x`가 내부적으로 계산되는 임시 변수가 아니라 함수의 인자 등으로 처음 넘겨받은 값이라면 변하지 않는 것이 더욱 좋을 것입니다.\n\n#### 문자열 연결 연산자\n\n`+` 연산자는 피연산자 중 문자열이 하나라도 존재할 때 문자열로 형변환하여 연결합니다.\n\n```javascript\n1 + \"1\" // 11\n1 + \"1\" + 1 + 0 // 1110\n\n// true는 1로, false는 0으로 변환\n1 + true // 2\n1 + false // 1\n\n// null은 0으로 변환\n1 + null // 1\n\n// undefined는 정의되지 않았기 때문에\n// 숫자로 변환되지 않음\n1 + undefined // NaN\n\n// 문자열에 + 붙이면 숫자타입으로 변환\n1 + \"1\" // 2\n```\n\n<br/>\n\n---\n\n### 할당 연산자 (Assignment Operator)\n\n할당 연산자는 우항 피연산자의 평가 결과를 좌항 변수에 할당합니다.\n\n| 연산자 | 동작       | 부수효과                                   |\n| ------ | ---------- | ------------------------------------------ |\n| =      | 할당       | 우항의 표현식 결과 값을 좌항의 변수에 할당 |\n| +=     | x = x + 2  | \"                                          |\n| -=     | x = x - 2  | \"                                          |\n| \\*=    | x = x \\* 2 | \"                                          |\n| /=     | x = x / 2  | \"                                          |\n| %=     | x = x % 2  | \"                                          |\n\n```javascript\nlet x = 3\n\nx += 3 // 6\n\nx -= 3 // 3\n\nx *= 3 // 9\n\nx /= 3 // 3\n\nx %= 3 // 0\n```\n\n<br/>\n\n---\n\n### 비교 연산자\n\n비교 연산자는 좌항과 우항의 피연산자를 비교해 그 값을 불리언(true/false) 타입으로 반환합니다.\n\n#### 동등 비교 연산자 (Equality Operator)\n\n값이 **동등**한 지를 평가하는 연산자입니다.\n\n여기서 동등하다는 자바스크립트 엔진이 자체적으로 형변환을 한 후에 비교했을 때에 같다고 평가되었다는 의미입니다.  \n자바스크립트는 굉장히 자유로운 언어라고 했죠? 따라서 변수를 할당하면 자체적으로 타입을 추론합니다. 그리고 동등한지를 평가할 때 **암묵적인 타입 변환**을 합니다. 이런 형변환은 이따금 약간의 골칫거리가 되기도 하는데요. 형변환에 대해서는 추후 자세히 다룰 예정입니다. 지금은 자바스크립트가 타입을 추론해 바꾸기도 한다는 점만 알고 가기로 해요.\n\n예시를 보겠습니다.\n\n```javascript\n2 == 2 // true\n\n// 암묵적 타입 변환해 타입이 같을 경우에\n2 == \"2\" // true\n```\n\n분명 숫자와 문자열을 비교했는데 두 값이 같다고 `true`를 반환하네요.\n동등 비교가 타입을 바꿔서도 검사해주니 좋다고 생각할 수도 있지만, 사실 클린 코드를 작성하는 데에는 취약점입니다. 이미 우리는 앞서 타입 변환이 일어나 `1 + '1'`이 `11`이 되는 걸 확인했죠. 비슷한 예기치 못한 결과를 낳을 수 있기 때문에 **일치 비교 연산자**를 쓰는 것을 권장합니다.\n\n#### 일치 비교 연산자 (Strict Equality Operator)\n\n일치 비교 연산자는 **타입과 값**이 모두 같을 경우에만 true를 반환합니다. 동등 비교보다 한층 강화된 연산자이기 때문에 **엄격한 동등 연산자**입니다.\n\n```javascript\n2 === 2 // true\n\n2 === \"2\" // false\n```\n\n일치 비교 연산자로 다 비교할 수 있으면 좋겠지만, 유의해야 할 값이 있습니다. 바로 `NaN`입니다.\n\n```javascript\nNaN === NaN // false\n```\n\nMDN의 설명을 참고하면, `NaN`은 자신과 일치하지 않는 유일한 값입니다 (NaN is the only value that compares unequal to itself). 이건 일종의 버그에\n\n따라서 `isNaN()`\n\n#### 부동등/불일치 비교 연산자 (Inequality / String Inequality Operator)\n\n동등, 일치가 있다면 동등하지 않은 것과 불일치하는 것도 비교할 수 있어야겠죠?\n\n자바스크립트에서는 `!` 느낌표를 **NOT** 의미로 사용합니다.\n\n```javascript\n1 != 5 // true\n1 !== \"1\" // true\n```\n\n동등/일치 연산자에 `!`를 붙여주면, 부동등 연산자는 값이 같지 않을 때, 불일치 연산자는 값과 타입이 모두 같지 않을 때 `true` 값을 리턴합니다.\n\n#### 대소 비교 연산자\n\n수학 연산에서 쓰이는 기호와 같습니다.\n\n```javascript\n1 >= 2 // false\n2 > 1 // true\n```\n\n### 삼항 연산자 (Ternary Operator)\n\n삼항 연산자는 자바스크립트에서 유일하게 **3개의 피연산자**를 가지는 연산자입니다.\n\n삼항 연산자는 조건식의 평가에 따라 반환되는 값이 달라집니다.\n\n삼항 연산자를 세 부분으로 나누어 살펴보겠습니다.\n\n![삼항연산자](https://user-images.githubusercontent.com/76241233/191170567-ccb8f67f-0b77-40d8-8199-7a73eabe51de.png)\n\n`?` 전까지는 조건식이 들어갑니다. 조건식의 결과는 Boolean 타입으로 평가되고, 만약 Boolean 타입이 아니라면 암묵적인 형변환을 통해 그 값을 Boolean으로 변환합니다.\n\n만약 조건식이 `true`라면 `?` 뒤의 값이, `false`라면 `:` 뒤의 값이 삼항연산자의 값으로 평가됩니다.\n\n```javascript\nfunction isAdult(age) {\n  return age > 19 ? \"You are an adult!\" : \"You are too young...\"\n}\n\nisAdult(15) // 'You are too young...'\n\nisAdult(24) // You are an adult!\n```\n\n삼항 연산자는 `if...else`문과 비슷하다고 생각할 수 있는데요. 유의해야 할 차이점이 있습니다. `if...else`는 **조건문**이고, 삼항 연산자는 **표현식**이란 점입니다.\n\n이전 글에서 값, 식, 문의 차이를 알아보며 문은 변수에 할당할 수 없지만, 표현식은 값으로 평가되어 할당할 수 있다고 설명한 바가 있습니다. 따라서 값처럼 사용할 수 있는 삼항 연산자는 무척 유용합니다.\n\n<br/>\n\n---\n\n### 논리 연산자 (Logical Operator)\n\n논리 연산자는 우항과 좌항의 피연산자를 논리적으로 연산합니다.\n\n논리적으로 연산한다는 말이 조금 어렵게 느껴집니다. 간단하게 Boolean 연산이라고 생각하면 됩니다. 논리연산은 `true`와 `false`만 존재하는 연산입니다.\n\n| 연산자 | 동작          | 의미                               |\n| ------ | ------------- | ---------------------------------- |\n| \\|\\|   | 논리합(OR)    | 피연산자 중 하나라도 true이면 true |\n| &&     | 논리곱(AND)   | 피연산자 모두 true여야 true        |\n| !      | 논리부정(NOT) | 피연산자의 값을 반전한 값 반환     |\n\n이렇게만 봐서는 좀 어렵습니다. 예제를 함께 살펴보겠습니다.\n\n```javascript\n// 논리합 (||)\ntrue || true // true\ntrue || false // true\nfalse || true // true\nfalse || false // false\n\n// 논리곱(&&)\ntrue && true // true\ntrue && false // false\nfalse && true // false\nfalse && false // false\n\n// 부정 (!)\n!true // false\n!false // true\n```\n\n논리 부정 연산자(!)는 항상 Boolean값으로 반환되는데, 피연산자의 값이 Boolean이 아니면 Boolean 값으로 암묵적 형변환하여 평가합니다.\n\n```javascript\nconsole.log(!0) // true\nconsole.log(!\"Any String\") // false\n```\n\n논리 곱 연산자(&&)는 늘 2개의 피연산자 중 하나로 평가됩니다.\n\n```javascript\nconsole.log(\"Apple\" && \"Banana\") // Banana\n```\n\n<br/>\n\n---\n\n### typeof\n\ntypeof 연산자는 이름에서 알 수 있듯 피연산자의 타입을 문자열로 반환합니다.\n\ntypeof 연산자가 반환하는 값의 종류는 다음과 같습니다.\n\n- string\n- number\n- boolean\n- undefined\n- symbol\n- object\n- function\n\n사실 typeof 로 검사해도 우리가 원하는 타입과 정확히 맞아떨어지는 결과가 반환되지만은 않습니다.\n\n```javascript\ntypeof \"\" // string (null 예상)\ntypeof NaN // number\ntypeof null // object\ntypeof [] // object\ntypeof new Date() // object\n```\n\n조금 이상하죠? 특히 `null`을 검사했는데 object로 넘기는 건 정말 이상합니다. 이건 자바스크립트의 버그입니다. 하지만 기존에 이미 작성된 코드와의 호환을 위해 의도적으로 남긴 버그입니다.\n\n따라서 null을 체크할 때에는 `===`일치 연산자를 사용하는 것이 좋습니다.\n\nES6 이후 자바스크립트 스펙에서 추가된 연산자들은 추후 알아보도록 하겠습니다.\n\n다음 글에서는 제어문에 대해 알아보겠습니다.\n\n◾ [값, 식, 문](/tech/let-me-know-js-a-bit-js-value-expression-statement) 👈 이전 글 보기  \n◾ [제어문(1) - 조건문](/tech/let-me-know-js-a-bit-js-control-flow-statement-conditional) 👈 다음 글 보기\n"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%97%B0%EC%82%B0%EC%9E%90operator%EB%9E%80\">연산자(Operator)란?</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90-arithmetic-operator\">산술 연산자 (Arithmetic Operator)</a></p>\n<ul>\n<li><a href=\"#%EC%9D%B4%ED%95%AD-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90-binary-operator\">이항 산술 연산자 (Binary Operator)</a></li>\n<li><a href=\"#%EB%8B%A8%ED%95%AD-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90-unary-operator\">단항 산술 연산자 (Unary Operator)</a></li>\n<li><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%B0%EA%B2%B0-%EC%97%B0%EC%82%B0%EC%9E%90\">문자열 연결 연산자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%95%A0%EB%8B%B9-%EC%97%B0%EC%82%B0%EC%9E%90-assignment-operator\">할당 연산자 (Assignment Operator)</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90\">비교 연산자</a></p>\n<ul>\n<li><a href=\"#%EB%8F%99%EB%93%B1-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90-equality-operator\">동등 비교 연산자 (Equality Operator)</a></li>\n<li><a href=\"#%EC%9D%BC%EC%B9%98-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90-strict-equality-operator\">일치 비교 연산자 (Strict Equality Operator)</a></li>\n<li><a href=\"#%EB%B6%80%EB%8F%99%EB%93%B1%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90-inequality--string-inequality-operator\">부동등/불일치 비교 연산자 (Inequality / String Inequality Operator)</a></li>\n<li><a href=\"#%EB%8C%80%EC%86%8C-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90\">대소 비교 연산자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%82%BC%ED%95%AD-%EC%97%B0%EC%82%B0%EC%9E%90-ternary-operator\">삼항 연산자 (Ternary Operator)</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0%EC%9E%90-logical-operator\">논리 연산자 (Logical Operator)</a></p>\n</li>\n<li>\n<p><a href=\"#typeof\">typeof</a></p>\n</li>\n</ul>\n</li>\n</ul>"}}]}},"pageContext":{"slug":"/tech/let-me-know-js-a-bit-js-operator"}},
    "staticQueryHashes": ["2665612806"]}