{"componentChunkName":"component---src-templates-blog-post-js","path":"/tech/react-pattern-provider","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"category":"tech","slug":"/tech/react-pattern-provider","tags":["Patterns"],"date":"2022-10-01","img":null,"title":"프로바이더 패턴"},"excerpt":"프로바이더 패턴 (Provider Pattern…","html":"<h2 id=\"프로바이더-패턴-provider-pattern\" style=\"position:relative;\">프로바이더 패턴 (Provider Pattern)<a href=\"#%ED%94%84%EB%A1%9C%EB%B0%94%EC%9D%B4%EB%8D%94-%ED%8C%A8%ED%84%B4-provider-pattern\" aria-label=\"프로바이더 패턴 provider pattern permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여러 컴포넌트들이 데이터를 공유해서 사용해야 하는 경우에 사용할 수 있는 패턴입니다.</p>\n<p>보통 컴포넌트 간에 데이터 전달이 필요하면 <code class=\"language-text\">props</code>를 통해서 전달합니다. 하지만 앱 내의 모든 컴포넌트들이 데이터에 접근해야 한다면 <code class=\"language-text\">props</code>만으로는 한계가 있습니다.</p>\n<h3 id=\"prop-drilling-안티-패턴\" style=\"position:relative;\">prop drilling 안티 패턴<a href=\"#prop-drilling-%EC%95%88%ED%8B%B0-%ED%8C%A8%ED%84%B4\" aria-label=\"prop drilling 안티 패턴 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>리액트 컴포넌트 트리에서 props로 데이터를 전달하기 위해 사용하는 것입니다. 다만 props를 <strong>하위 컴포넌트로 전달하는 용도로만</strong> 사용하는 경우에 이것을 prop drilling이라고 부릅니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">function App() {\r\n  const data = { ... }\r\n\r\n  return (\r\n    &lt;div&gt;\r\n      &lt;SideBar data={data} /&gt;\r\n      &lt;Content data={data} /&gt;\r\n    &lt;/div&gt;\r\n  )\r\n}\r\n\r\nconst SideBar = ({ data }) =&gt; &lt;List data={data} /&gt;\r\nconst List = ({ data }) =&gt; &lt;ListItem data={data} /&gt;\r\nconst ListItem = ({ data }) =&gt; &lt;span&gt;{data.listItem}&lt;/span&gt;\r\n\r\nconst Content = ({ data }) =&gt; (\r\n  &lt;div&gt;\r\n    &lt;Header data={data} /&gt;\r\n    &lt;Block data={data} /&gt;\r\n  &lt;/div&gt;\r\n)\r\nconst Header = ({ data }) =&gt; &lt;div&gt;{data.title}&lt;/div&gt;\r\nconst Block = ({ data }) =&gt; &lt;Text data={data} /&gt;\r\nconst Text = ({ data }) =&gt; &lt;h1&gt;{data.text}&lt;/h1&gt;</code>\n        </deckgo-highlight-code>\n<p>위 코드에서 <code class=\"language-text\">Sidebar</code>는 data를 prop으로 전달받지만, 정작 자기 자신 내에서는 사용하지 않고 <code class=\"language-text\">List</code> 컴포넌트로 보냅니다. 또 이 <code class=\"language-text\">List</code> 컴포넌트를 <code class=\"language-text\">ListItem</code> 컴포넌트로 보내기 위해서만 prop을 받습니다.</p>\n<p>이런 방식으로 props를 <em>내리꽂는</em> 것은 꽤 지저분합니다. 만약 <code class=\"language-text\">data</code> 라는 프로퍼티 이름을 변경해야 하는 경우 모든 컴포넌트를 수정하게 됩니다.</p>\n<p><strong>Provider 패턴</strong>은 이런 안티 패턴을 해결하는 경우에 유용합니다.</p>\n<h3 id=\"provider-패턴-사용하기\" style=\"position:relative;\">Provider 패턴 사용하기<a href=\"#provider-%ED%8C%A8%ED%84%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"provider 패턴 사용하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>먼저 React의 Context에 대해 알아보겠습니다.</p>\n<h4 id=\"react-context\" style=\"position:relative;\">React Context<a href=\"#react-context\" aria-label=\"react context permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>리액트에는 Context가 있습니다. 리액트 공식문서 <a href=\"https://ko.reactjs.org/docs/context.html\">Context</a>를 보면, <strong>트리 단계마다 명시적으로 props를 넘겨주지 않아도 많은 컴포넌트가 이러한 값을 공유</strong>할 수 있게 한다고 설명하고 있습니다.</p>\n<p>이런 Context는 <strong>컴포넌트 트리 속에서</strong> 전역적인 데이터를 공유할 때 사용합니다.</p>\n<h4 id=\"provider-컴포넌트-동작\" style=\"position:relative;\">Provider 컴포넌트 동작<a href=\"#provider-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%8F%99%EC%9E%91\" aria-label=\"provider 컴포넌트 동작 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const DataContext = React.createContext()\r\n\r\nfunction App() {\r\n  const data = { ... }\r\n\r\n  return (\r\n    &lt;div&gt;\r\n      &lt;DataContext.Provider value={data}&gt;\r\n        &lt;SideBar /&gt;\r\n        &lt;Content /&gt;\r\n      &lt;/DataContext.Provider&gt;\r\n    &lt;/div&gt;\r\n  )\r\n}</code>\n        </deckgo-highlight-code>\n<br/>\n<ol>\n<li>React.createContext로 <code class=\"language-text\">Context</code> 객체를 생성합니다.</li>\n<li>데이터를 공유할 모든 컴포넌트를 <code class=\"language-text\">Provider</code>로 감쌉니다.</li>\n<li><code class=\"language-text\">value</code>라는 이름의 prop으로 하위 컴포넌트에 넘겨줄 데이터를 받습니다.</li>\n</ol>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">const DataContext = React.createContext();\r\n\r\nfunction App() {\r\n  const data = { ... }\r\n\r\n  return (\r\n    &lt;div&gt;\r\n      &lt;SideBar /&gt;\r\n      &lt;Content /&gt;\r\n    &lt;/div&gt;\r\n  )\r\n}\r\n\r\nconst SideBar = () =&gt; &lt;List /&gt;\r\nconst List = () =&gt; &lt;ListItem /&gt;\r\nconst Content = () =&gt; &lt;div&gt;&lt;Header /&gt;&lt;Block /&gt;&lt;/div&gt;\r\n\r\nfunction ListItem() {\r\n  const { data } = React.useContext(DataContext);\r\n  return &lt;span&gt;{data.listItem}&lt;/span&gt;;\r\n}\r\n\r\nfunction Text() {\r\n  const { data } = React.useContext(DataContext);\r\n  return &lt;h1&gt;{data.text}&lt;/h1&gt;;\r\n}\r\n\r\nfunction Header() {\r\n  const { data } = React.useContext(DataContext);\r\n  return &lt;div&gt;{data.title}&lt;/div&gt;;\r\n}</code>\n        </deckgo-highlight-code>\n<ol start=\"4\">\n<li>prop을 받을 하위 컴포넌트들은 React의 <code class=\"language-text\">useContext</code> 메소드를 활용해 data에 접근합니다.</li>\n</ol>\n<h4 id=\"hooks\" style=\"position:relative;\">Hooks<a href=\"#hooks\" aria-label=\"hooks permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>위 코드에서는 각 컴포넌트들이 <code class=\"language-text\">useContext</code>를 직접 import해 사용하였습니다. 이를 대신해 필요로 하는 Context를 직접 반환하는 Hook을 구현할 수 있습니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// theme 변경 hook\r\n\r\nfunction useThemeContext() {\r\n  const theme = useContext(ThemeContext)\r\n  if (!theme) {\r\n    throw new Error(&#39;useThemeContext must be used within ThemeProvider&#39;)\r\n  }\r\n  return theme\r\n}</code>\n        </deckgo-highlight-code>\n<p>컴포넌트를 <code class=\"language-text\">ThemeContext.Provider</code>로 직접 래핑하지 않고, HOC(고차 컴포넌트)로 만들면 Context 로직과 렌더링 로직이 분리되어 재사용성이 증가합니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">// Context 부\r\nfunction ThemeProvider({ children }) {\r\n  const [theme, setTheme] = useState(&#39;dark&#39;)\r\n\r\n  function toggleTheme() {\r\n    setTheme(theme === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;)\r\n  }\r\n\r\n  const providerValue = {\r\n    theme: themes[theme],\r\n    toggleTheme,\r\n  }\r\n\r\n  return (\r\n    &lt;ThemeContext.Provider value={providerValue}&gt;\r\n      {children}\r\n    &lt;/ThemeContext.Provider&gt;\r\n  )\r\n}\r\n\r\n// 렌더링 부\r\nexport default function App() {\r\n  return (\r\n    &lt;div className={`App theme-${theme}`}&gt;\r\n      &lt;ThemeProvider&gt;\r\n        &lt;Toggle /&gt;\r\n        &lt;List /&gt;\r\n      &lt;/ThemeProvider&gt;\r\n    &lt;/div&gt;\r\n  )\r\n}</code>\n        </deckgo-highlight-code>\n<p>하위 컴포넌트들은 <code class=\"language-text\">ThemeContext</code>에 접근하기 위해 <code class=\"language-text\">useThemeContext</code>를 사용하면 됩니다.</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"blackboard\"  >\n          <code slot=\"code\">export default function TextBox() {\r\n  const theme = useThemeContext()\r\n\r\n  return &lt;li style={theme.theme}&gt;...&lt;/li&gt;\r\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"provider-패턴을-사용하는-때\" style=\"position:relative;\">Provider 패턴을 사용하는 때<a href=\"#provider-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%95%8C\" aria-label=\"provider 패턴을 사용하는 때 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>프로바이더 패턴은 필요한 컴포넌트에서 필요한 데이터를 전역적으로 접근할 수 있어 유용합니다.</p>\n<p>보통 UI테마를 여러 컴포넌트들이 공유해 사용할 때 이 패턴을 사용합니다. (ex. 다크모드 / 라이트모드)</p>\n<h2 id=\"장단점\" style=\"position:relative;\">장/단점<a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"장단점 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"장점\" style=\"position:relative;\">장점<a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>컴포넌트 트리의 각각 노드에 데이터를 전달하지 않아도 다수 컴포넌트에 데이터 공유 가능</li>\n<li>리팩토링 과정에서 개발자가 실수할 확률을 줄여줌</li>\n<li>prop drilling 안티 패턴을 사용하지 않아도 됨</li>\n</ul>\n<h3 id=\"단점\" style=\"position:relative;\">단점<a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>Provider 패턴을 과도하게 사용시 성능에러가 발생할 수 있음</li>\n<li>Context를 참조하는 모든 컴포넌트들은 컨텍스트 변경 시마다 <strong>모두 리렌더링</strong>됨</li>\n</ul>\n<h3 id=\"결론\" style=\"position:relative;\">결론<a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>쓰지 않는 값의 업데이트로 인해 리렌더링 되는 것을 방지하기 위해 여러 Provider로 쪼갤 필요가 있다.</p>","internal":{"content":"\r\n## 프로바이더 패턴 (Provider Pattern)\r\n\r\n여러 컴포넌트들이 데이터를 공유해서 사용해야 하는 경우에 사용할 수 있는 패턴입니다.\r\n\r\n보통 컴포넌트 간에 데이터 전달이 필요하면 `props`를 통해서 전달합니다. 하지만 앱 내의 모든 컴포넌트들이 데이터에 접근해야 한다면 `props`만으로는 한계가 있습니다.\r\n\r\n\r\n### prop drilling 안티 패턴\r\n\r\n리액트 컴포넌트 트리에서 props로 데이터를 전달하기 위해 사용하는 것입니다. 다만 props를 **하위 컴포넌트로 전달하는 용도로만** 사용하는 경우에 이것을 prop drilling이라고 부릅니다.\r\n\r\n\r\n```javascript\r\nfunction App() {\r\n  const data = { ... }\r\n\r\n  return (\r\n    <div>\r\n      <SideBar data={data} />\r\n      <Content data={data} />\r\n    </div>\r\n  )\r\n}\r\n\r\nconst SideBar = ({ data }) => <List data={data} />\r\nconst List = ({ data }) => <ListItem data={data} />\r\nconst ListItem = ({ data }) => <span>{data.listItem}</span>\r\n\r\nconst Content = ({ data }) => (\r\n  <div>\r\n    <Header data={data} />\r\n    <Block data={data} />\r\n  </div>\r\n)\r\nconst Header = ({ data }) => <div>{data.title}</div>\r\nconst Block = ({ data }) => <Text data={data} />\r\nconst Text = ({ data }) => <h1>{data.text}</h1>\r\n```\r\n\r\n위 코드에서 `Sidebar`는 data를 prop으로 전달받지만, 정작 자기 자신 내에서는 사용하지 않고 `List` 컴포넌트로 보냅니다. 또 이 `List` 컴포넌트를 `ListItem` 컴포넌트로 보내기 위해서만 prop을 받습니다.\r\n\r\n이런 방식으로 props를 *내리꽂는* 것은 꽤 지저분합니다. 만약 `data` 라는 프로퍼티 이름을 변경해야 하는 경우 모든 컴포넌트를 수정하게 됩니다. \r\n\r\n**Provider 패턴**은 이런 안티 패턴을 해결하는 경우에 유용합니다.\r\n\r\n\r\n### Provider 패턴 사용하기\r\n\r\n먼저 React의 Context에 대해 알아보겠습니다.\r\n\r\n#### React Context\r\n\r\n리액트에는 Context가 있습니다. 리액트 공식문서 [Context](https://ko.reactjs.org/docs/context.html)를 보면, **트리 단계마다 명시적으로 props를 넘겨주지 않아도 많은 컴포넌트가 이러한 값을 공유**할 수 있게 한다고 설명하고 있습니다.\r\n\r\n이런 Context는 **컴포넌트 트리 속에서** 전역적인 데이터를 공유할 때 사용합니다.\r\n\r\n\r\n\r\n#### Provider 컴포넌트 동작\r\n\r\n```javascript\r\nconst DataContext = React.createContext()\r\n\r\nfunction App() {\r\n  const data = { ... }\r\n\r\n  return (\r\n    <div>\r\n      <DataContext.Provider value={data}>\r\n        <SideBar />\r\n        <Content />\r\n      </DataContext.Provider>\r\n    </div>\r\n  )\r\n}\r\n```\r\n<br/>\r\n\r\n1. React.createContext로 `Context` 객체를 생성합니다.\r\n2. 데이터를 공유할 모든 컴포넌트를 `Provider`로 감쌉니다. \r\n3. `value`라는 이름의 prop으로 하위 컴포넌트에 넘겨줄 데이터를 받습니다.\r\n\r\n\r\n```javascript\r\nconst DataContext = React.createContext();\r\n\r\nfunction App() {\r\n  const data = { ... }\r\n\r\n  return (\r\n    <div>\r\n      <SideBar />\r\n      <Content />\r\n    </div>\r\n  )\r\n}\r\n\r\nconst SideBar = () => <List />\r\nconst List = () => <ListItem />\r\nconst Content = () => <div><Header /><Block /></div>\r\n\r\nfunction ListItem() {\r\n  const { data } = React.useContext(DataContext);\r\n  return <span>{data.listItem}</span>;\r\n}\r\n\r\nfunction Text() {\r\n  const { data } = React.useContext(DataContext);\r\n  return <h1>{data.text}</h1>;\r\n}\r\n\r\nfunction Header() {\r\n  const { data } = React.useContext(DataContext);\r\n  return <div>{data.title}</div>;\r\n}\r\n```\r\n\r\n4. prop을 받을 하위 컴포넌트들은 React의 `useContext` 메소드를 활용해 data에 접근합니다.\r\n\r\n\r\n#### Hooks\r\n\r\n위 코드에서는 각 컴포넌트들이 `useContext`를 직접 import해 사용하였습니다. 이를 대신해 필요로 하는 Context를 직접 반환하는 Hook을 구현할 수 있습니다.\r\n\r\n```javascript\r\n// theme 변경 hook\r\n\r\nfunction useThemeContext() {\r\n  const theme = useContext(ThemeContext)\r\n  if (!theme) {\r\n    throw new Error('useThemeContext must be used within ThemeProvider')\r\n  }\r\n  return theme\r\n}\r\n```\r\n\r\n컴포넌트를 `ThemeContext.Provider`로 직접 래핑하지 않고, HOC(고차 컴포넌트)로 만들면 Context 로직과 렌더링 로직이 분리되어 재사용성이 증가합니다.\r\n\r\n```javascript\r\n// Context 부\r\nfunction ThemeProvider({ children }) {\r\n  const [theme, setTheme] = useState('dark')\r\n\r\n  function toggleTheme() {\r\n    setTheme(theme === 'light' ? 'dark' : 'light')\r\n  }\r\n\r\n  const providerValue = {\r\n    theme: themes[theme],\r\n    toggleTheme,\r\n  }\r\n\r\n  return (\r\n    <ThemeContext.Provider value={providerValue}>\r\n      {children}\r\n    </ThemeContext.Provider>\r\n  )\r\n}\r\n\r\n// 렌더링 부\r\nexport default function App() {\r\n  return (\r\n    <div className={`App theme-${theme}`}>\r\n      <ThemeProvider>\r\n        <Toggle />\r\n        <List />\r\n      </ThemeProvider>\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n하위 컴포넌트들은 `ThemeContext`에 접근하기 위해 `useThemeContext`를 사용하면 됩니다.\r\n\r\n```javascript\r\nexport default function TextBox() {\r\n  const theme = useThemeContext()\r\n\r\n  return <li style={theme.theme}>...</li>\r\n}\r\n```\r\n\r\n\r\n### Provider 패턴을 사용하는 때\r\n\r\n프로바이더 패턴은 필요한 컴포넌트에서 필요한 데이터를 전역적으로 접근할 수 있어 유용합니다.\r\n\r\n보통 UI테마를 여러 컴포넌트들이 공유해 사용할 때 이 패턴을 사용합니다. (ex. 다크모드 / 라이트모드)\r\n\r\n\r\n## 장/단점\r\n\r\n### 장점\r\n\r\n* 컴포넌트 트리의 각각 노드에 데이터를 전달하지 않아도 다수 컴포넌트에 데이터 공유 가능\r\n* 리팩토링 과정에서 개발자가 실수할 확률을 줄여줌\r\n* prop drilling 안티 패턴을 사용하지 않아도 됨\r\n\r\n\r\n### 단점\r\n\r\n* Provider 패턴을 과도하게 사용시 성능에러가 발생할 수 있음\r\n* Context를 참조하는 모든 컴포넌트들은 컨텍스트 변경 시마다 **모두 리렌더링**됨\r\n\r\n\r\n### 결론\r\n\r\n쓰지 않는 값의 업데이트로 인해 리렌더링 되는 것을 방지하기 위해 여러 Provider로 쪼갤 필요가 있다."},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%EB%B0%94%EC%9D%B4%EB%8D%94-%ED%8C%A8%ED%84%B4-provider-pattern\">프로바이더 패턴 (Provider Pattern)</a></p>\n<ul>\n<li>\n<p><a href=\"#prop-drilling-%EC%95%88%ED%8B%B0-%ED%8C%A8%ED%84%B4\">prop drilling 안티 패턴</a></p>\n</li>\n<li>\n<p><a href=\"#provider-%ED%8C%A8%ED%84%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">Provider 패턴 사용하기</a></p>\n<ul>\n<li><a href=\"#react-context\">React Context</a></li>\n<li><a href=\"#provider-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%8F%99%EC%9E%91\">Provider 컴포넌트 동작</a></li>\n<li><a href=\"#hooks\">Hooks</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#provider-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%95%8C\">Provider 패턴을 사용하는 때</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\">장/단점</a></p>\n<ul>\n<li><a href=\"#%EC%9E%A5%EC%A0%90\">장점</a></li>\n<li><a href=\"#%EB%8B%A8%EC%A0%90\">단점</a></li>\n<li><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></li>\n</ul>\n</li>\n</ul>"}}]}},"pageContext":{"slug":"/tech/react-pattern-provider"}},"staticQueryHashes":["2665612806"]}